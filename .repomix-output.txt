This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo, **/certdata.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
Ambulando.xcodeproj/
  project.xcworkspace/
    contents.xcworkspacedata
Sources/
  Ambulando/
    Assets.xcassets/
      AppIcon.appiconset/
        Contents.json
      Contents.json
    Models/
      AudioEvent.swift
      BlossomError.swift
      BlossomServerInfo.swift
      BlossomServerManager.swift
      OutboxDebugModels.swift
    Shapes/
      FootprintShape.swift
    ViewModels/
      OutboxDebugViewModel.swift
    Views/
      Debug/
        DebugMenuView.swift
        OutboxDebugView.swift
        OutboxSummaryCard.swift
        OutboxUserDetailView.swift
      AccountSectionView.swift
      AudioEventCard.swift
      AuthenticationView.swift
      BlossomSettingsView.swift
      HomeFeedView.swift
      QRScannerView.swift
      RelayManagementView.swift
      RelaySelectorView.swift
      SettingsView.swift
      UserProfileView.swift
    AmbulandoApp.swift
    AmbulandoIcon.swift
    ContentView.swift
    Info.plist
build.sh
deploy.sh
project.yml
README.md
refresh-project.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Ambulando.xcodeproj/project.xcworkspace/contents.xcworkspacedata">
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>
</file>

<file path="Sources/Ambulando/Assets.xcassets/AppIcon.appiconset/Contents.json">
{
  "images" : [
    {
      "filename" : "icon-20@2x.png",
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "filename" : "icon-20@3x.png",
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "20x20"
    },
    {
      "filename" : "icon-29@2x.png",
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "filename" : "icon-29@3x.png",
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "filename" : "icon-40@2x.png",
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "filename" : "icon-40@3x.png",
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "40x40"
    },
    {
      "filename" : "icon-60@2x.png",
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "filename" : "icon-60@3x.png",
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "filename" : "icon-20.png",
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "20x20"
    },
    {
      "filename" : "icon-20@2x~ipad.png",
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "filename" : "icon-29.png",
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "29x29"
    },
    {
      "filename" : "icon-29@2x~ipad.png",
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "filename" : "icon-40.png",
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "40x40"
    },
    {
      "filename" : "icon-40@2x~ipad.png",
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "filename" : "icon-76.png",
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "76x76"
    },
    {
      "filename" : "icon-76@2x.png",
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "76x76"
    },
    {
      "filename" : "icon-83.5@2x.png",
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "83.5x83.5"
    },
    {
      "filename" : "icon-1024.png",
      "idiom" : "ios-marketing",
      "scale" : "1x",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Sources/Ambulando/Assets.xcassets/Contents.json">
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Sources/Ambulando/Models/AudioEvent.swift">
import Foundation
import NDKSwift
struct AudioEvent: Identifiable, Equatable {
    let id: String
    let event: NDKEvent
    let author: NDKUser
    let audioURL: String
    let createdAt: Date
    let isReply: Bool
    let replyTo: String?
    let replyToPubkey: String?
    let webOfTrustScore: Double
    let waveform: [Double]?
    let duration: TimeInterval?
    // Reaction tracking (populated separately)
    var likeCount: Int = 0
    var zapCount: Int = 0
    var replyCount: Int = 0
    static func == (lhs: AudioEvent, rhs: AudioEvent) -> Bool {
        lhs.id == rhs.id
    }
    var sortScore: Double {
        // Combine recency and web of trust
        let recencyScore = 1.0 - (Date().timeIntervalSince(createdAt) / (7 * 24 * 60 * 60)) // Decay over 7 days
        return (webOfTrustScore * 0.7) + (max(0, recencyScore) * 0.3)
    }
    var hashtags: [String] {
        // Extract hashtags from 't' tags
        return event.tags.compactMap { tag in
            guard tag.count >= 2 && tag[0] == "t" else { return nil }
            return tag[1]
        }
    }
    static func from(event: NDKEvent, webOfTrustScore: Double) -> AudioEvent? {
        guard let audioURL = extractAudioURL(from: event.content) else { return nil }
        let isReply = event.kind == 1244
        let replyTo = isReply ? extractReplyTo(from: event) : nil
        let replyToPubkey = isReply ? extractReplyToPubkey(from: event) : nil
        // Parse imeta tag for waveform and duration
        let (waveform, duration) = extractMetadata(from: event, audioURL: audioURL)
        return AudioEvent(
            id: event.id,
            event: event,
            author: NDKUser(pubkey: event.pubkey),
            audioURL: audioURL,
            createdAt: Date(timeIntervalSince1970: TimeInterval(event.createdAt)),
            isReply: isReply,
            replyTo: replyTo,
            replyToPubkey: replyToPubkey,
            webOfTrustScore: webOfTrustScore,
            waveform: waveform,
            duration: duration
        )
    }
    private static func extractAudioURL(from content: String) -> String? {
        // Content should be a direct URL
        guard let url = URL(string: content),
              url.scheme == "https" || url.scheme == "http" else {
            return nil
        }
        return content
    }
    private static func extractReplyTo(from event: NDKEvent) -> String? {
        // Look for 'e' tag that marks the reply target
        for tag in event.tags {
            if tag.count >= 2 && tag[0] == "e" {
                return tag[1]
            }
        }
        return nil
    }
    private static func extractReplyToPubkey(from event: NDKEvent) -> String? {
        // Look for 'p' tag that indicates who we're replying to
        for tag in event.tags {
            if tag.count >= 2 && tag[0] == "p" {
                return tag[1]
            }
        }
        return nil
    }
    private static func extractMetadata(from event: NDKEvent, audioURL: String) -> (waveform: [Double]?, duration: TimeInterval?) {
        // Use NDKSwift's built-in imeta parsing
        let audioImeta = event.imetas(for: audioURL).first
        // Extract waveform from additionalFields
        var waveform: [Double]?
        if let waveformString = audioImeta?.additionalFields["waveform"] {
            waveform = waveformString.split(separator: " ")
                .compactMap { Double($0) }
        }
        // Extract duration from additionalFields
        var duration: TimeInterval?
        if let durationString = audioImeta?.additionalFields["duration"] {
            duration = TimeInterval(durationString)
        }
        return (waveform, duration)
    }
}
</file>

<file path="Sources/Ambulando/Models/BlossomError.swift">
import Foundation
enum BlossomError: LocalizedError {
    case uploadFailed
    case noServersAvailable
    case invalidServerURL
    case authenticationFailed
    var errorDescription: String? {
        switch self {
        case .uploadFailed:
            return "Failed to upload file to Blossom server"
        case .noServersAvailable:
            return "No Blossom servers available"
        case .invalidServerURL:
            return "Invalid Blossom server URL"
        case .authenticationFailed:
            return "Failed to authenticate with Blossom server"
        }
    }
}
</file>

<file path="Sources/Ambulando/Models/BlossomServerInfo.swift">
import Foundation
import NDKSwift
struct BlossomServerInfo: Identifiable, Equatable {
    let id: String
    let url: String
    let name: String
    let description: String
    let isPaid: Bool
    let isWhitelisted: Bool
    let whitelistMessage: String?
    let paidMessage: String?
    init(url: String, name: String, description: String, isPaid: Bool = false, isWhitelisted: Bool = false, whitelistMessage: String? = nil, paidMessage: String? = nil) {
        self.id = url
        self.url = url
        self.name = name
        self.description = description
        self.isPaid = isPaid
        self.isWhitelisted = isWhitelisted
        self.whitelistMessage = whitelistMessage
        self.paidMessage = paidMessage
    }
    init(from event: NDKEvent) {
        self.id = event.id
        self.description = event.content
        var extractedUrl = ""
        var extractedName = ""
        var extractedIsPaid = false
        var extractedIsWhitelisted = false
        var extractedWhitelistMessage: String?
        var extractedPaidMessage: String?
        // Parse tags
        for tag in event.tags {
            guard tag.count >= 2 else { continue }
            switch tag[0] {
            case "d":
                extractedUrl = tag[1]
            case "name":
                extractedName = tag[1]
            case "paid":
                extractedIsPaid = true
                if tag.count > 1 {
                    extractedPaidMessage = tag[1]
                }
            case "whitelist":
                extractedIsWhitelisted = true
                if tag.count > 1 {
                    extractedWhitelistMessage = tag[1]
                }
            default:
                break
            }
        }
        self.url = extractedUrl
        self.name = extractedName.isEmpty ? Self.extractServerName(from: extractedUrl) : extractedName
        self.isPaid = extractedIsPaid
        self.isWhitelisted = extractedIsWhitelisted
        self.whitelistMessage = extractedWhitelistMessage
        self.paidMessage = extractedPaidMessage
    }
    /// Extracts a display name from the server URL
    private static func extractServerName(from url: String) -> String {
        // Remove protocol
        var name = url
        if let range = name.range(of: "://") {
            name = String(name[range.upperBound...])
        }
        // Remove trailing slash
        if name.hasSuffix("/") {
            name = String(name.dropLast())
        }
        // Remove www.
        if name.hasPrefix("www.") {
            name = String(name.dropFirst(4))
        }
        // Take first part before any path
        if let firstSlash = name.firstIndex(of: "/") {
            name = String(name[..<firstSlash])
        }
        return name
    }
    /// Display subtitle for the server
    var subtitle: String? {
        if isPaid && isWhitelisted {
            return "Paid & Whitelisted"
        } else if isPaid {
            return "Paid"
        } else if isWhitelisted {
            return "Whitelist Required"
        } else {
            return "Free"
        }
    }
    /// Combined access message
    var accessMessage: String? {
        if let paidMsg = paidMessage, let whitelistMsg = whitelistMessage {
            return "\(paidMsg)\n\(whitelistMsg)"
        } else if let paidMsg = paidMessage {
            return paidMsg
        } else if let whitelistMsg = whitelistMessage {
            return whitelistMsg
        } else if isPaid || isWhitelisted {
            return "Access restricted"
        }
        return nil
    }
}
</file>

<file path="Sources/Ambulando/Models/BlossomServerManager.swift">
import Foundation
import NDKSwift
@MainActor
class BlossomServerManager: ObservableObject {
    @Published var servers: [String] = []
    @Published var isLoading = false
    @Published var suggestedServers: [BlossomServerInfo] = []
    private let ndk: NDK?
    private let defaultServer = "https://blossom.primal.net"
    private static let userDefaultsKey = "AmbulandoBlossomServers"
    private var suggestionsTask: Task<Void, Never>?
    init(ndk: NDK?) {
        self.ndk = ndk
        loadServers()
        loadSuggestedServers()
    }
    deinit {
        suggestionsTask?.cancel()
    }
    // MARK: - Server Management
    func loadServers() {
        guard let ndk = ndk, let signer = ndk.signer else {
            // Fallback to default server
            servers = [defaultServer]
            return
        }
        isLoading = true
        Task {
            do {
                // Get the public key from signer
                let pubkey = try await signer.pubkey
                // Fetch user's blossom server list event (kind 10063)
                let filter = NDKFilter(
                    authors: [pubkey],
                    kinds: [10063],
                    limit: 1
                )
                // Use observe to get the event
                let dataSource = ndk.observe(filter: filter, maxAge: 300, cachePolicy: .cacheWithNetwork)
                var foundEvent = false
                for await event in dataSource.events {
                    parseServersFromEvent(event)
                    foundEvent = true
                    break // We only need the first event
                }
                if !foundEvent {
                    // No server list found, use default
                    servers = [defaultServer]
                }
            } catch {
                print("Failed to fetch blossom server list: \(error)")
                servers = [defaultServer]
            }
            isLoading = false
        }
    }
    private func parseServersFromEvent(_ event: NDKEvent) {
        var serverList: [String] = []
        // Parse server tags
        for tag in event.tags {
            if tag.count >= 2 && tag[0] == "server" {
                let serverUrl = tag[1]
                if !serverUrl.isEmpty {
                    serverList.append(serverUrl)
                }
            }
        }
        // Update servers list
        servers = serverList.isEmpty ? [defaultServer] : serverList
        // Save to UserDefaults
        saveToUserDefaults()
    }
    // MARK: - Persistence
    private func saveToUserDefaults() {
        UserDefaults.standard.set(servers, forKey: Self.userDefaultsKey)
    }
    private func loadFromUserDefaults() {
        if let savedServers = UserDefaults.standard.stringArray(forKey: Self.userDefaultsKey),
           !savedServers.isEmpty {
            servers = savedServers
        } else {
            servers = [defaultServer]
        }
    }
    // MARK: - Server Management UI
    func addServer(_ serverUrl: String) {
        guard !servers.contains(serverUrl) else { return }
        servers.append(serverUrl)
        saveToUserDefaults()
        publishServerList()
    }
    func removeServer(_ serverUrl: String) {
        servers.removeAll { $0 == serverUrl }
        if servers.isEmpty {
            servers = [defaultServer]
        }
        saveToUserDefaults()
        publishServerList()
    }
    func removeServer(at index: Int) {
        guard index >= 0 && index < servers.count else { return }
        servers.remove(at: index)
        if servers.isEmpty {
            servers = [defaultServer]
        }
        saveToUserDefaults()
        publishServerList()
    }
    func moveServer(from source: IndexSet, to destination: Int) {
        var newServers = servers
        for index in source.sorted(by: >) {
            let server = newServers.remove(at: index)
            let adjustedDestination = destination > index ? destination - 1 : destination
            newServers.insert(server, at: adjustedDestination)
        }
        servers = newServers
        saveToUserDefaults()
        publishServerList()
    }
    private func publishServerList() {
        guard let ndk = ndk else { return }
        Task {
            do {
                // Create server list event (kind 10063)
                let (_, _) = try await ndk.publish { builder in
                    var eventBuilder = builder.kind(10063)
                    // Add server tags
                    for server in servers {
                        eventBuilder = eventBuilder.tag(["server", server])
                    }
                    return eventBuilder
                }
                print("Published blossom server list")
            } catch {
                print("Failed to publish server list: \(error)")
            }
        }
    }
    // MARK: - Convenience
    /// Get all servers for fallback upload attempts
    var allServers: [String] {
        servers.isEmpty ? [defaultServer] : servers
    }
    // MARK: - Suggested Servers
    func loadSuggestedServers() {
        guard let ndk = ndk else {
            print("BlossomServerManager: No NDK instance available for loading suggested servers")
            return
        }
        suggestionsTask?.cancel()
        suggestionsTask = Task {
            print("BlossomServerManager: Starting to fetch kind 36363 events...")
            // Create filter for Blossom server discovery events (kind 36363)
            let filter = NDKFilter(
                kinds: [36363],
                limit: 50
            )
            // Use observe with cache-first approach
            let dataSource = ndk.observe(filter: filter, maxAge: 3600, cachePolicy: .cacheWithNetwork)
            var serverInfos: [BlossomServerInfo] = []
            var seenUrls = Set<String>()
            for await event in dataSource.events {
                if Task.isCancelled { break }
                let serverInfo = BlossomServerInfo(from: event)
                // Only add if we haven't seen this URL before and it's valid
                if !serverInfo.url.isEmpty && !seenUrls.contains(serverInfo.url) {
                    seenUrls.insert(serverInfo.url)
                    serverInfos.append(serverInfo)
                    print("BlossomServerManager: Found server: \(serverInfo.name) at \(serverInfo.url)")
                    // Update UI incrementally
                    suggestedServers = serverInfos.sorted { server1, server2 in
                        // Sort free servers first, then by name
                        if server1.isPaid == server2.isPaid && server1.isWhitelisted == server2.isWhitelisted {
                            return server1.name < server2.name
                        }
                        if server1.isPaid != server2.isPaid {
                            return !server1.isPaid
                        }
                        return !server1.isWhitelisted
                    }
                }
            }
            print("BlossomServerManager: Finished loading suggested servers. Found \(serverInfos.count) servers.")
        }
    }
}
</file>

<file path="Sources/Ambulando/Models/OutboxDebugModels.swift">
import Foundation
import NDKSwift
// MARK: - Outbox Debug Data Models
enum RelayHealth: CaseIterable {
    case excellent  // Score > 0.8, low latency, no recent failures
    case good       // Score > 0.6, moderate latency, few failures
    case fair       // Score > 0.4, higher latency, some failures
    case poor       // Score > 0.2, high latency, many failures
    case unknown    // No metadata available
    var color: String {
        switch self {
        case .excellent: return "green"
        case .good: return "blue"
        case .fair: return "yellow"
        case .poor: return "red"
        case .unknown: return "gray"
        }
    }
    var description: String {
        switch self {
        case .excellent: return "Excellent"
        case .good: return "Good"
        case .fair: return "Fair"
        case .poor: return "Poor"
        case .unknown: return "Unknown"
        }
    }
    static func from(metadata: RelayMetadata?) -> RelayHealth {
        guard let metadata = metadata,
              let score = metadata.score else {
            return .unknown
        }
        if score > 0.8 { return .excellent }
        if score > 0.6 { return .good }
        if score > 0.4 { return .fair }
        if score > 0.2 { return .poor }
        return .poor
    }
}
struct OutboxSummary {
    let totalUsers: Int
    let totalRelays: Int
    let averageRelaysPerUser: Double
    let lastUpdateTime: Date
    let unknownUsersCount: Int
    let activeSubscriptions: Int
    static let empty = OutboxSummary(
        totalUsers: 0,
        totalRelays: 0,
        averageRelaysPerUser: 0,
        lastUpdateTime: Date(),
        unknownUsersCount: 0,
        activeSubscriptions: 0
    )
}
struct OutboxEntry: Identifiable {
    let id = UUID()
    let pubkey: String
    let displayName: String?
    let npub: String
    let readRelays: [RelayDisplayInfo]
    let writeRelays: [RelayDisplayInfo]
    let lastUpdated: Date
    let source: String
    let totalRelayCount: Int
    init(from item: NDKOutboxItem, displayName: String? = nil) {
        self.pubkey = item.pubkey
        self.displayName = displayName
        let pubkeyData = Data(hex: item.pubkey) ?? Data()
        self.npub = (try? Bech32.encode(hrp: "npub", data: [UInt8](pubkeyData))) ?? item.pubkey
        self.readRelays = item.readRelays.map { RelayDisplayInfo(from: $0) }
        self.writeRelays = item.writeRelays.map { RelayDisplayInfo(from: $0) }
        self.lastUpdated = item.fetchedAt
        self.source = item.source.description
        self.totalRelayCount = item.allRelayURLs.count
    }
}
struct RelayDisplayInfo: Identifiable {
    let id = UUID()
    let url: String
    let metadata: RelayMetadata?
    let score: Double?
    let health: RelayHealth
    let lastConnected: Date?
    let averageResponseTime: Double?
    let failureCount: Int
    let requiresAuth: Bool
    let requiresPayment: Bool
    init(from relayInfo: RelayInfo) {
        self.url = relayInfo.url
        self.metadata = relayInfo.metadata
        self.score = relayInfo.metadata?.score
        self.health = RelayHealth.from(metadata: relayInfo.metadata)
        self.lastConnected = relayInfo.metadata?.lastConnectedAt
        self.averageResponseTime = relayInfo.metadata?.avgResponseTime
        self.failureCount = relayInfo.metadata?.failureCount ?? 0
        self.requiresAuth = relayInfo.metadata?.authRequired ?? false
        self.requiresPayment = relayInfo.metadata?.paymentRequired ?? false
    }
}
// MARK: - Extensions
extension RelayListSource {
    var description: String {
        switch self {
        case .nip65:
            return "NIP-65 Relay List"
        case .contactList:
            return "Contact List (Kind 3)"
        case .manual:
            return "Manual Configuration"
        case .unknown:
            return "Unknown Source"
        }
    }
}
extension Data {
    init?(hex: String) {
        let len = hex.count / 2
        var data = Data(capacity: len)
        var i = hex.startIndex
        for _ in 0..<len {
            let j = hex.index(i, offsetBy: 2)
            let bytes = hex[i..<j]
            if var num = UInt8(bytes, radix: 16) {
                data.append(&num, count: 1)
            } else {
                return nil
            }
            i = j
        }
        self = data
    }
}
</file>

<file path="Sources/Ambulando/Shapes/FootprintShape.swift">
import SwiftUI
struct FootprintShape: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()
        let width = rect.width
        let height = rect.height
        // Main foot shape (heel to ball)
        path.move(to: CGPoint(x: width * 0.5, y: height * 0.95))
        // Left side of heel
        path.addCurve(
            to: CGPoint(x: width * 0.3, y: height * 0.75),
            control1: CGPoint(x: width * 0.35, y: height * 0.95),
            control2: CGPoint(x: width * 0.3, y: height * 0.85)
        )
        // Left side arch
        path.addCurve(
            to: CGPoint(x: width * 0.35, y: height * 0.45),
            control1: CGPoint(x: width * 0.3, y: height * 0.65),
            control2: CGPoint(x: width * 0.32, y: height * 0.55)
        )
        // Left side to ball of foot
        path.addCurve(
            to: CGPoint(x: width * 0.45, y: height * 0.3),
            control1: CGPoint(x: width * 0.38, y: height * 0.35),
            control2: CGPoint(x: width * 0.4, y: height * 0.3)
        )
        // Right side to ball of foot
        path.addCurve(
            to: CGPoint(x: width * 0.65, y: height * 0.45),
            control1: CGPoint(x: width * 0.55, y: height * 0.3),
            control2: CGPoint(x: width * 0.62, y: height * 0.35)
        )
        // Right side arch
        path.addCurve(
            to: CGPoint(x: width * 0.7, y: height * 0.75),
            control1: CGPoint(x: width * 0.68, y: height * 0.55),
            control2: CGPoint(x: width * 0.7, y: height * 0.65)
        )
        // Right side of heel
        path.addCurve(
            to: CGPoint(x: width * 0.5, y: height * 0.95),
            control1: CGPoint(x: width * 0.7, y: height * 0.85),
            control2: CGPoint(x: width * 0.65, y: height * 0.95)
        )
        path.closeSubpath()
        // Big toe
        path.addEllipse(in: CGRect(
            x: width * 0.4,
            y: height * 0.08,
            width: width * 0.2,
            height: height * 0.15
        ))
        // Second toe
        path.addEllipse(in: CGRect(
            x: width * 0.25,
            y: height * 0.12,
            width: width * 0.15,
            height: height * 0.12
        ))
        // Middle toe
        path.addEllipse(in: CGRect(
            x: width * 0.15,
            y: height * 0.18,
            width: width * 0.12,
            height: height * 0.1
        ))
        // Fourth toe
        path.addEllipse(in: CGRect(
            x: width * 0.12,
            y: height * 0.25,
            width: width * 0.1,
            height: height * 0.08
        ))
        // Little toe
        path.addEllipse(in: CGRect(
            x: width * 0.15,
            y: height * 0.31,
            width: width * 0.08,
            height: height * 0.06
        ))
        return path
    }
}
</file>

<file path="Sources/Ambulando/ViewModels/OutboxDebugViewModel.swift">
import Foundation
import SwiftUI
import NDKSwift
@MainActor
class OutboxDebugViewModel: ObservableObject {
    @Published var outboxEntries: [OutboxEntry] = []
    @Published var summary: OutboxSummary = .empty
    @Published var isLoading = true
    @Published var errorMessage: String?
    private var relayUpdateTask: Task<Void, Never>?
    private let ndk: NDK?
    init(ndk: NDK?) {
        self.ndk = ndk
    }
    deinit {
        relayUpdateTask?.cancel()
    }
    func loadData() async {
        guard let ndk = ndk else {
            errorMessage = "NDK not available"
            isLoading = false
            return
        }
        isLoading = true
        errorMessage = nil
        // Get current outbox statistics
        let stats = await ndk.outbox.getRelayUpdateStats()
        // Get all tracked outbox items
        let outboxItems = await getAllOutboxItems()
        // Process entries and calculate summary
        let entries = await processOutboxItems(outboxItems)
        let summaryData = calculateSummary(from: entries, stats: stats)
        // Update UI
        self.outboxEntries = entries
        self.summary = summaryData
        isLoading = false
        // Start real-time updates
        startRealtimeUpdates()
    }
    private func getAllOutboxItems() async -> [NDKOutboxItem] {
        guard let ndk = ndk else { return [] }
        // Get all tracked items from the outbox manager
        return await ndk.outbox.getAllTrackedItems()
    }
    private func processOutboxItems(_ items: [NDKOutboxItem]) async -> [OutboxEntry] {
        var entries: [OutboxEntry] = []
        for item in items {
            // Try to get display name from profile cache
            let displayName = await getDisplayName(for: item.pubkey)
            let entry = OutboxEntry(from: item, displayName: displayName)
            entries.append(entry)
        }
        // Sort by most recently updated
        return entries.sorted { $0.lastUpdated > $1.lastUpdated }
    }
    private func getDisplayName(for pubkey: String) async -> String? {
        guard let ndk = ndk else { return nil }
        // Attempt to get profile from cache (don't fetch if not available)
        for await profile in await ndk.profileManager.observe(for: pubkey, maxAge: TimeConstants.hour) {
            if let profile = profile {
                return profile.name ?? profile.displayName
            }
        }
        return nil
    }
    private func calculateSummary(from entries: [OutboxEntry], stats: RelayUpdateStats) -> OutboxSummary {
        let allRelays = Set(entries.flatMap { entry in
            entry.readRelays.map { $0.url } + entry.writeRelays.map { $0.url }
        })
        let totalRelayCount = entries.reduce(0) { $0 + $1.totalRelayCount }
        let averageRelays = entries.isEmpty ? 0 : Double(totalRelayCount) / Double(entries.count)
        return OutboxSummary(
            totalUsers: entries.count,
            totalRelays: allRelays.count,
            averageRelaysPerUser: averageRelays,
            lastUpdateTime: entries.first?.lastUpdated ?? Date(),
            unknownUsersCount: stats.totalUnknownAuthors,
            activeSubscriptions: stats.activeSubscriptions
        )
    }
    private func startRealtimeUpdates() {
        guard let ndk = ndk else { return }
        relayUpdateTask?.cancel()
        relayUpdateTask = Task {
            for await update in await ndk.outbox.relayUpdates {
                await handleRelayUpdate(update)
            }
        }
    }
    private func handleRelayUpdate(_ update: RelayUpdateEvent) async {
        // Update existing entry or add new one
        if let index = outboxEntries.firstIndex(where: { $0.pubkey == update.pubkey }) {
            // Update existing entry
            let displayName = await getDisplayName(for: update.pubkey)
            let mockItem = createMockOutboxItem(from: update, displayName: displayName)
            let updatedEntry = OutboxEntry(from: mockItem, displayName: displayName)
            outboxEntries[index] = updatedEntry
        } else {
            // Add new entry
            let displayName = await getDisplayName(for: update.pubkey)
            let mockItem = createMockOutboxItem(from: update, displayName: displayName)
            let newEntry = OutboxEntry(from: mockItem, displayName: displayName)
            outboxEntries.append(newEntry)
        }
        // Recalculate summary
        if let ndk = ndk {
            let stats = await ndk.outbox.getRelayUpdateStats()
            summary = calculateSummary(from: outboxEntries, stats: stats)
        }
        // Re-sort entries
        outboxEntries.sort { $0.lastUpdated > $1.lastUpdated }
    }
    private func createMockOutboxItem(from update: RelayUpdateEvent, displayName: String?) -> NDKOutboxItem {
        // Convert RelayUpdateEvent to NDKOutboxItem for UI display
        let readRelays = Set(update.relays.readRelays.map { url in
            RelayInfo(url: url, metadata: nil) // We don't have metadata in the update
        })
        let writeRelays = Set(update.relays.writeRelays.map { url in
            RelayInfo(url: url, metadata: nil)
        })
        return NDKOutboxItem(
            pubkey: update.pubkey,
            readRelays: readRelays,
            writeRelays: writeRelays,
            fetchedAt: update.timestamp,
            source: .nip65 // Assume NIP-65 for updates
        )
    }
    func refresh() {
        Task {
            await loadData()
        }
    }
    func trackUser(_ pubkey: String) {
        guard let ndk = ndk else { return }
        Task {
            await ndk.outbox.trackUser(pubkey)
        }
    }
    func untrackUser(_ pubkey: String) {
        guard let ndk = ndk else { return }
        Task {
            await ndk.outbox.untrackUser(pubkey)
        }
    }
    // Filtered entries for search
    func filteredEntries(searchText: String) -> [OutboxEntry] {
        guard !searchText.isEmpty else { return outboxEntries }
        let lowercased = searchText.lowercased()
        return outboxEntries.filter { entry in
            entry.pubkey.lowercased().contains(lowercased) ||
            entry.npub.lowercased().contains(lowercased) ||
            entry.displayName?.lowercased().contains(lowercased) == true ||
            entry.readRelays.contains { $0.url.lowercased().contains(lowercased) } ||
            entry.writeRelays.contains { $0.url.lowercased().contains(lowercased) }
        }
    }
}
// MARK: - Mock Data for Development
extension OutboxDebugViewModel {
    static func createMockData() -> OutboxDebugViewModel {
        let viewModel = OutboxDebugViewModel(ndk: nil)
        // Create some mock entries for UI development
        let mockEntries = [
            createMockEntry(
                pubkey: "82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2",
                displayName: "jack",
                readRelays: ["wss://relay.damus.io", "wss://nos.lol"],
                writeRelays: ["wss://relay.damus.io", "wss://nostr.wine"]
            ),
            createMockEntry(
                pubkey: "3bf0c63fcb93463407af97a5e5ee64fa883d107ef9e558472c4eb9aaaefa459d",
                displayName: "fiatjaf",
                readRelays: ["wss://nostr.wine", "wss://relay.nostr.band"],
                writeRelays: ["wss://nostr.wine"]
            )
        ]
        viewModel.outboxEntries = mockEntries
        viewModel.summary = OutboxSummary(
            totalUsers: mockEntries.count,
            totalRelays: 4,
            averageRelaysPerUser: 2.5,
            lastUpdateTime: Date(),
            unknownUsersCount: 15,
            activeSubscriptions: 3
        )
        viewModel.isLoading = false
        return viewModel
    }
    private static func createMockEntry(
        pubkey: String,
        displayName: String,
        readRelays: [String],
        writeRelays: [String]
    ) -> OutboxEntry {
        let readRelayInfos = readRelays.map { url in
            RelayInfo(url: url, metadata: RelayMetadata(
                score: Double.random(in: 0.3...0.9),
                lastConnectedAt: Date().addingTimeInterval(-Double.random(in: 0...3600)),
                avgResponseTime: Double.random(in: 100...500),
                failureCount: Int.random(in: 0...5),
                authRequired: Bool.random(),
                paymentRequired: Bool.random()
            ))
        }
        let writeRelayInfos = writeRelays.map { url in
            RelayInfo(url: url, metadata: RelayMetadata(
                score: Double.random(in: 0.3...0.9),
                lastConnectedAt: Date().addingTimeInterval(-Double.random(in: 0...3600)),
                avgResponseTime: Double.random(in: 100...500),
                failureCount: Int.random(in: 0...5),
                authRequired: Bool.random(),
                paymentRequired: Bool.random()
            ))
        }
        let mockItem = NDKOutboxItem(
            pubkey: pubkey,
            readRelays: Set(readRelayInfos),
            writeRelays: Set(writeRelayInfos),
            fetchedAt: Date().addingTimeInterval(-Double.random(in: 0...86400)),
            source: .nip65
        )
        return OutboxEntry(from: mockItem, displayName: displayName)
    }
}
</file>

<file path="Sources/Ambulando/Views/Debug/DebugMenuView.swift">
import SwiftUI
import NDKSwift
struct DebugMenuView: View {
    @EnvironmentObject var nostrManager: NostrManager
    var body: some View {
        List {
            Section {
                NavigationLink(destination: OutboxDebugView(ndk: nostrManager.ndk)) {
                    DebugMenuRow(
                        title: "Outbox Configuration",
                        subtitle: "View relay mappings and outbox statistics",
                        icon: "network.badge.shield.half.filled",
                        iconColor: .purple
                    )
                }
                NavigationLink(destination: RelayDebugView()) {
                    DebugMenuRow(
                        title: "Relay Connections",
                        subtitle: "Monitor relay status and connections",
                        icon: "antenna.radiowaves.left.and.right",
                        iconColor: .blue
                    )
                }
                NavigationLink(destination: CacheDebugView()) {
                    DebugMenuRow(
                        title: "Cache Inspector",
                        subtitle: "View cached events and profiles",
                        icon: "externaldrive.fill",
                        iconColor: .green
                    )
                }
                NavigationLink(destination: EventDebugView()) {
                    DebugMenuRow(
                        title: "Event Inspector",
                        subtitle: "View raw event data and signatures",
                        icon: "doc.text.magnifyingglass",
                        iconColor: .orange
                    )
                }
            }
            .listRowBackground(Color.white.opacity(0.05))
            Section {
                DebugInfoRow(
                    title: "NDK Version",
                    value: getNDKVersion()
                )
                DebugInfoRow(
                    title: "Active Relays",
                    value: getActiveRelayCount()
                )
                DebugInfoRow(
                    title: "Authentication",
                    value: getAuthStatus()
                )
                DebugInfoRow(
                    title: "Session Active",
                    value: getSessionStatus()
                )
            } header: {
                Text("System Info")
                    .foregroundColor(Color.white.opacity(0.8))
            }
            .listRowBackground(Color.white.opacity(0.05))
        }
        .navigationTitle("Debug Tools")
        .navigationBarTitleDisplayMode(.inline)
        .scrollContentBackground(.hidden)
        .background(
            LinearGradient(
                gradient: Gradient(colors: [
                    Color(red: 0.05, green: 0.02, blue: 0.08),
                    Color(red: 0.02, green: 0.01, blue: 0.03),
                    Color.black
                ]),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .ignoresSafeArea()
        )
        .preferredColorScheme(.dark)
    }
    private func getNDKVersion() -> String {
        // This would ideally come from NDKSwift package info
        return "1.0.0" // Placeholder
    }
    private func getActiveRelayCount() -> String {
        guard nostrManager.ndk != nil else { return "0" }
        // This would ideally come from relay pool
        return "\(nostrManager.defaultRelays.count + nostrManager.userAddedRelays.count)"
    }
    private func getAuthStatus() -> String {
        return nostrManager.isAuthenticated ? "Authenticated" : "Not Authenticated"
    }
    private func getSessionStatus() -> String {
        guard let ndk = nostrManager.ndk else { return "No NDK" }
        return ndk.sessionData != nil ? "Active" : "Inactive"
    }
}
struct DebugMenuRow: View {
    let title: String
    let subtitle: String
    let icon: String
    let iconColor: Color
    var body: some View {
        HStack(spacing: 16) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundColor(iconColor)
                .frame(width: 32, height: 32)
            VStack(alignment: .leading, spacing: 4) {
                Text(title)
                    .font(.headline)
                    .foregroundColor(.white)
                Text(subtitle)
                    .font(.caption)
                    .foregroundColor(.white.opacity(0.7))
                    .lineLimit(2)
            }
            Spacer()
            Image(systemName: "chevron.right")
                .font(.caption)
                .foregroundColor(.white.opacity(0.4))
        }
        .padding(.vertical, 4)
    }
}
struct DebugInfoRow: View {
    let title: String
    let value: String
    var body: some View {
        HStack {
            Text(title)
                .foregroundColor(.white.opacity(0.8))
            Spacer()
            Text(value)
                .foregroundColor(.white)
                .fontWeight(.medium)
        }
    }
}
// MARK: - Placeholder Views (to be implemented later)
struct RelayDebugView: View {
    var body: some View {
        VStack {
            Image(systemName: "antenna.radiowaves.left.and.right")
                .font(.system(size: 64))
                .foregroundColor(.blue.opacity(0.6))
            Text("Relay Debug")
                .font(.title2)
                .foregroundColor(.white)
                .padding(.top)
            Text("Coming soon...")
                .foregroundColor(.white.opacity(0.6))
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(
            LinearGradient(
                gradient: Gradient(colors: [
                    Color(red: 0.05, green: 0.02, blue: 0.08),
                    Color(red: 0.02, green: 0.01, blue: 0.03),
                    Color.black
                ]),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .ignoresSafeArea()
        )
        .navigationTitle("Relay Debug")
        .preferredColorScheme(.dark)
    }
}
struct CacheDebugView: View {
    var body: some View {
        VStack {
            Image(systemName: "externaldrive.fill")
                .font(.system(size: 64))
                .foregroundColor(.green.opacity(0.6))
            Text("Cache Inspector")
                .font(.title2)
                .foregroundColor(.white)
                .padding(.top)
            Text("Coming soon...")
                .foregroundColor(.white.opacity(0.6))
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(
            LinearGradient(
                gradient: Gradient(colors: [
                    Color(red: 0.05, green: 0.02, blue: 0.08),
                    Color(red: 0.02, green: 0.01, blue: 0.03),
                    Color.black
                ]),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .ignoresSafeArea()
        )
        .navigationTitle("Cache Inspector")
        .preferredColorScheme(.dark)
    }
}
struct EventDebugView: View {
    var body: some View {
        VStack {
            Image(systemName: "doc.text.magnifyingglass")
                .font(.system(size: 64))
                .foregroundColor(.orange.opacity(0.6))
            Text("Event Inspector")
                .font(.title2)
                .foregroundColor(.white)
                .padding(.top)
            Text("Coming soon...")
                .foregroundColor(.white.opacity(0.6))
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(
            LinearGradient(
                gradient: Gradient(colors: [
                    Color(red: 0.05, green: 0.02, blue: 0.08),
                    Color(red: 0.02, green: 0.01, blue: 0.03),
                    Color.black
                ]),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .ignoresSafeArea()
        )
        .navigationTitle("Event Inspector")
        .preferredColorScheme(.dark)
    }
}
// MARK: - Preview
struct DebugMenuView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationView {
            DebugMenuView()
                .environmentObject(NostrManager())
        }
        .preferredColorScheme(.dark)
    }
}
</file>

<file path="Sources/Ambulando/Views/Debug/OutboxDebugView.swift">
import SwiftUI
import NDKSwift
struct OutboxDebugView: View {
    @StateObject private var viewModel: OutboxDebugViewModel
    @State private var searchText = ""
    @State private var selectedEntry: OutboxEntry?
    init(ndk: NDK?) {
        self._viewModel = StateObject(wrappedValue: OutboxDebugViewModel(ndk: ndk))
    }
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                if viewModel.isLoading {
                    loadingView
                } else if let error = viewModel.errorMessage {
                    errorView(error)
                } else {
                    contentView
                }
            }
            .navigationTitle("Outbox Debug")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Refresh") {
                        viewModel.refresh()
                    }
                    .foregroundColor(.purple)
                }
            }
        }
        .task {
            await viewModel.loadData()
        }
        .sheet(item: $selectedEntry) { entry in
            OutboxUserDetailView(entry: entry)
        }
        .background(
            LinearGradient(
                gradient: Gradient(colors: [
                    Color(red: 0.05, green: 0.02, blue: 0.08),
                    Color(red: 0.02, green: 0.01, blue: 0.03),
                    Color.black
                ]),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .ignoresSafeArea()
        )
        .preferredColorScheme(.dark)
    }
    private var contentView: some View {
        VStack(spacing: 0) {
            // Summary Card
            OutboxSummaryCard(summary: viewModel.summary)
                .padding(.horizontal)
                .padding(.top)
            // Search Bar
            searchBar
                .padding(.horizontal)
                .padding(.vertical, 8)
            // User List
            List(filteredEntries) { entry in
                OutboxEntryRow(entry: entry) {
                    selectedEntry = entry
                }
                .listRowBackground(Color.white.opacity(0.05))
            }
            .scrollContentBackground(.hidden)
        }
    }
    private var searchBar: some View {
        HStack {
            Image(systemName: "magnifyingglass")
                .foregroundColor(.white.opacity(0.6))
            TextField("Search users or relays...", text: $searchText)
                .textFieldStyle(PlainTextFieldStyle())
                .foregroundColor(.white)
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 8)
        .background(Color.white.opacity(0.1))
        .cornerRadius(8)
    }
    private var filteredEntries: [OutboxEntry] {
        viewModel.filteredEntries(searchText: searchText)
    }
    private var loadingView: some View {
        VStack(spacing: 16) {
            ProgressView()
                .scaleEffect(1.2)
                .tint(.purple)
            Text("Loading outbox data...")
                .foregroundColor(.white.opacity(0.8))
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
    private func errorView(_ message: String) -> some View {
        VStack(spacing: 16) {
            Image(systemName: "exclamationmark.triangle")
                .font(.system(size: 48))
                .foregroundColor(.yellow)
            Text("Error")
                .font(.headline)
                .foregroundColor(.white)
            Text(message)
                .foregroundColor(.white.opacity(0.8))
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            Button("Retry") {
                viewModel.refresh()
            }
            .foregroundColor(.purple)
            .padding(.top)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}
struct OutboxEntryRow: View {
    let entry: OutboxEntry
    let onTap: () -> Void
    var body: some View {
        Button(action: onTap) {
            HStack(spacing: 12) {
                // User Info
                VStack(alignment: .leading, spacing: 4) {
                    if let displayName = entry.displayName {
                        Text(displayName)
                            .font(.headline)
                            .foregroundColor(.white)
                    }
                    Text(String(entry.pubkey.prefix(16)) + "...")
                        .font(.system(.caption, design: .monospaced))
                        .foregroundColor(.white.opacity(0.7))
                    Text(entry.source)
                        .font(.caption2)
                        .foregroundColor(.white.opacity(0.5))
                }
                Spacer()
                // Relay Counts
                VStack(alignment: .trailing, spacing: 4) {
                    HStack(spacing: 8) {
                        RelayCountBadge(
                            count: entry.readRelays.count,
                            type: "R",
                            color: .blue
                        )
                        RelayCountBadge(
                            count: entry.writeRelays.count,
                            type: "W",
                            color: .green
                        )
                    }
                    Text("\(entry.totalRelayCount) total")
                        .font(.caption2)
                        .foregroundColor(.white.opacity(0.6))
                }
                // Chevron
                Image(systemName: "chevron.right")
                    .font(.caption)
                    .foregroundColor(.white.opacity(0.4))
            }
            .padding(.vertical, 4)
        }
        .buttonStyle(PlainButtonStyle())
    }
}
struct RelayCountBadge: View {
    let count: Int
    let type: String
    let color: Color
    var body: some View {
        HStack(spacing: 2) {
            Text(type)
                .font(.caption2)
                .fontWeight(.medium)
            Text("\(count)")
                .font(.caption)
                .fontWeight(.bold)
        }
        .foregroundColor(.white)
        .padding(.horizontal, 6)
        .padding(.vertical, 2)
        .background(color.opacity(0.3))
        .overlay(
            RoundedRectangle(cornerRadius: 4)
                .stroke(color.opacity(0.6), lineWidth: 1)
        )
        .cornerRadius(4)
    }
}
// MARK: - Preview
struct OutboxDebugView_Previews: PreviewProvider {
    static var previews: some View {
        OutboxDebugView(ndk: nil)
            .preferredColorScheme(.dark)
    }
}
</file>

<file path="Sources/Ambulando/Views/Debug/OutboxSummaryCard.swift">
import SwiftUI
struct OutboxSummaryCard: View {
    let summary: OutboxSummary
    var body: some View {
        VStack(spacing: 16) {
            // Title
            HStack {
                Image(systemName: "network.badge.shield.half.filled")
                    .font(.title2)
                    .foregroundColor(.purple)
                Text("Outbox Summary")
                    .font(.title3)
                    .fontWeight(.semibold)
                    .foregroundColor(.white)
                Spacer()
                // Last update time
                if summary.lastUpdateTime != Date() {
                    VStack(alignment: .trailing, spacing: 2) {
                        Text("Last Updated")
                            .font(.caption2)
                            .foregroundColor(.white.opacity(0.6))
                        Text(summary.lastUpdateTime, style: .relative)
                            .font(.caption)
                            .foregroundColor(.white.opacity(0.8))
                    }
                }
            }
            // Stats Grid
            LazyVGrid(columns: [
                GridItem(.flexible()),
                GridItem(.flexible())
            ], spacing: 12) {
                StatCard(
                    title: "Total Users",
                    value: "\(summary.totalUsers)",
                    icon: "person.2.fill",
                    color: .blue
                )
                StatCard(
                    title: "Distinct Relays",
                    value: "\(summary.totalRelays)",
                    icon: "network",
                    color: .green
                )
                StatCard(
                    title: "Avg Relays/User",
                    value: String(format: "%.1f", summary.averageRelaysPerUser),
                    icon: "chart.bar.fill",
                    color: .orange
                )
                StatCard(
                    title: "Unknown Users",
                    value: "\(summary.unknownUsersCount)",
                    icon: "questionmark.circle.fill",
                    color: .yellow
                )
            }
            // Active Subscriptions
            if summary.activeSubscriptions > 0 {
                HStack {
                    Circle()
                        .fill(Color.green)
                        .frame(width: 8, height: 8)
                    Text("\(summary.activeSubscriptions) active subscriptions")
                        .font(.caption)
                        .foregroundColor(.white.opacity(0.8))
                    Spacer()
                }
                .padding(.top, 4)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.white.opacity(0.08))
                .overlay(
                    RoundedRectangle(cornerRadius: 16)
                        .stroke(Color.white.opacity(0.1), lineWidth: 1)
                )
        )
    }
}
struct StatCard: View {
    let title: String
    let value: String
    let icon: String
    let color: Color
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Image(systemName: icon)
                    .font(.caption)
                    .foregroundColor(color)
                Spacer()
            }
            Text(value)
                .font(.title2)
                .fontWeight(.bold)
                .foregroundColor(.white)
            Text(title)
                .font(.caption)
                .foregroundColor(.white.opacity(0.7))
                .lineLimit(1)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(color.opacity(0.15))
                .overlay(
                    RoundedRectangle(cornerRadius: 12)
                        .stroke(color.opacity(0.3), lineWidth: 1)
                )
        )
    }
}
// MARK: - Preview
struct OutboxSummaryCard_Previews: PreviewProvider {
    static var previews: some View {
        OutboxSummaryCard(
            summary: OutboxSummary(
                totalUsers: 42,
                totalRelays: 12,
                averageRelaysPerUser: 2.5,
                lastUpdateTime: Date().addingTimeInterval(-300),
                unknownUsersCount: 7,
                activeSubscriptions: 3
            )
        )
        .padding()
        .background(Color.black)
        .preferredColorScheme(.dark)
    }
}
</file>

<file path="Sources/Ambulando/Views/Debug/OutboxUserDetailView.swift">
import SwiftUI
import NDKSwift
struct OutboxUserDetailView: View {
    let entry: OutboxEntry
    @Environment(\.dismiss) private var dismiss
    @State private var copiedText: String?
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    // User Info Section
                    userInfoSection
                    // Relay Lists
                    if !entry.readRelays.isEmpty {
                        relaySection(
                            title: "Read Relays",
                            relays: entry.readRelays,
                            icon: "arrow.down.circle.fill",
                            color: .blue
                        )
                    }
                    if !entry.writeRelays.isEmpty {
                        relaySection(
                            title: "Write Relays",
                            relays: entry.writeRelays,
                            icon: "arrow.up.circle.fill",
                            color: .green
                        )
                    }
                    // Metadata Section
                    metadataSection
                }
                .padding()
            }
            .navigationTitle("Outbox Details")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(.purple)
                }
            }
            .background(
                LinearGradient(
                    gradient: Gradient(colors: [
                        Color(red: 0.05, green: 0.02, blue: 0.08),
                        Color(red: 0.02, green: 0.01, blue: 0.03),
                        Color.black
                    ]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
            )
        }
        .preferredColorScheme(.dark)
    }
    private var userInfoSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Display Name
            if let displayName = entry.displayName {
                Text(displayName)
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(.white)
            }
            // Pubkey
            CopyableRow(
                label: "Pubkey",
                value: entry.pubkey,
                displayValue: String(entry.pubkey.prefix(32)) + "...",
                copiedText: $copiedText
            )
            // Npub
            CopyableRow(
                label: "Npub",
                value: entry.npub,
                displayValue: String(entry.npub.prefix(32)) + "...",
                copiedText: $copiedText
            )
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.white.opacity(0.05))
        )
    }
    private func relaySection(title: String, relays: [RelayDisplayInfo], icon: String, color: Color) -> some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Image(systemName: icon)
                    .foregroundColor(color)
                Text(title)
                    .font(.headline)
                    .foregroundColor(.white)
                Spacer()
                Text("\(relays.count) relays")
                    .font(.caption)
                    .foregroundColor(.white.opacity(0.6))
            }
            VStack(spacing: 8) {
                ForEach(relays) { relay in
                    RelayDetailRow(relay: relay, copiedText: $copiedText)
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.white.opacity(0.05))
        )
    }
    private var metadataSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Metadata")
                .font(.headline)
                .foregroundColor(.white)
            LabeledContent("Source", value: entry.source)
                .foregroundColor(.white.opacity(0.8))
            LabeledContent("Last Updated", value: entry.lastUpdated.formatted())
                .foregroundColor(.white.opacity(0.8))
            LabeledContent("Total Relay Count", value: "\(entry.totalRelayCount)")
                .foregroundColor(.white.opacity(0.8))
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.white.opacity(0.05))
        )
    }
}
struct CopyableRow: View {
    let label: String
    let value: String
    let displayValue: String
    @Binding var copiedText: String?
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(label)
                .font(.caption)
                .foregroundColor(.white.opacity(0.6))
            HStack {
                Text(displayValue)
                    .font(.system(.body, design: .monospaced))
                    .foregroundColor(.white)
                Spacer()
                Button(action: { copyToClipboard(value) }) {
                    Image(systemName: copiedText == value ? "checkmark.circle.fill" : "doc.on.doc")
                        .foregroundColor(copiedText == value ? .green : .purple)
                }
            }
        }
    }
    private func copyToClipboard(_ text: String) {
        #if os(iOS)
        UIPasteboard.general.string = text
        #else
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(text, forType: .string)
        #endif
        withAnimation {
            copiedText = text
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            withAnimation {
                if copiedText == text {
                    copiedText = nil
                }
            }
        }
    }
}
struct RelayDetailRow: View {
    let relay: RelayDisplayInfo
    @Binding var copiedText: String?
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                // Health indicator
                Circle()
                    .fill(healthColor)
                    .frame(width: 8, height: 8)
                // Relay URL
                Text(relay.url)
                    .font(.system(.body, design: .monospaced))
                    .foregroundColor(.white)
                    .lineLimit(1)
                    .truncationMode(.middle)
                Spacer()
                // Copy button
                Button(action: { copyToClipboard(relay.url) }) {
                    Image(systemName: copiedText == relay.url ? "checkmark.circle.fill" : "doc.on.doc")
                        .font(.caption)
                        .foregroundColor(copiedText == relay.url ? .green : .purple.opacity(0.8))
                }
            }
            // Relay metadata
            HStack(spacing: 16) {
                // Health status
                HStack(spacing: 4) {
                    Text("Health:")
                        .font(.caption2)
                        .foregroundColor(.white.opacity(0.6))
                    Text(relay.health.description)
                        .font(.caption2)
                        .fontWeight(.medium)
                        .foregroundColor(healthColor)
                }
                // Score
                if let score = relay.score {
                    HStack(spacing: 4) {
                        Text("Score:")
                            .font(.caption2)
                            .foregroundColor(.white.opacity(0.6))
                        Text(String(format: "%.2f", score))
                            .font(.caption2)
                            .fontWeight(.medium)
                            .foregroundColor(.white)
                    }
                }
                // Response time
                if let avgTime = relay.averageResponseTime {
                    HStack(spacing: 4) {
                        Text("Avg:")
                            .font(.caption2)
                            .foregroundColor(.white.opacity(0.6))
                        Text("\(Int(avgTime))ms")
                            .font(.caption2)
                            .fontWeight(.medium)
                            .foregroundColor(.white)
                    }
                }
                Spacer()
            }
            // Additional metadata
            if relay.failureCount > 0 || relay.requiresAuth || relay.requiresPayment {
                HStack(spacing: 8) {
                    if relay.failureCount > 0 {
                        Label("\(relay.failureCount) failures", systemImage: "exclamationmark.triangle.fill")
                            .font(.caption2)
                            .foregroundColor(.yellow)
                    }
                    if relay.requiresAuth {
                        Label("Auth", systemImage: "lock.fill")
                            .font(.caption2)
                            .foregroundColor(.orange)
                    }
                    if relay.requiresPayment {
                        Label("Paid", systemImage: "bitcoinsign.circle.fill")
                            .font(.caption2)
                            .foregroundColor(.green)
                    }
                    Spacer()
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(Color.white.opacity(0.03))
        )
    }
    private var healthColor: Color {
        switch relay.health {
        case .excellent: return .green
        case .good: return .blue
        case .fair: return .yellow
        case .poor: return .red
        case .unknown: return .gray
        }
    }
    private func copyToClipboard(_ text: String) {
        #if os(iOS)
        UIPasteboard.general.string = text
        #else
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(text, forType: .string)
        #endif
        withAnimation {
            copiedText = text
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            withAnimation {
                if copiedText == text {
                    copiedText = nil
                }
            }
        }
    }
}
// MARK: - Preview
struct OutboxUserDetailView_Previews: PreviewProvider {
    static var previews: some View {
        let mockEntry = OutboxEntry(
            from: NDKOutboxItem(
                pubkey: "82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2",
                readRelays: Set([
                    RelayInfo(url: "wss://relay.damus.io", metadata: RelayMetadata(
                        score: 0.85,
                        lastConnectedAt: Date(),
                        avgResponseTime: 245,
                        failureCount: 1,
                        authRequired: false,
                        paymentRequired: false
                    )),
                    RelayInfo(url: "wss://nos.lol", metadata: RelayMetadata(
                        score: 0.72,
                        lastConnectedAt: Date(),
                        avgResponseTime: 180,
                        failureCount: 0,
                        authRequired: true,
                        paymentRequired: false
                    ))
                ]),
                writeRelays: Set([
                    RelayInfo(url: "wss://relay.damus.io", metadata: RelayMetadata(
                        score: 0.85,
                        lastConnectedAt: Date(),
                        avgResponseTime: 245,
                        failureCount: 1,
                        authRequired: false,
                        paymentRequired: false
                    )),
                    RelayInfo(url: "wss://nostr.wine", metadata: RelayMetadata(
                        score: 0.55,
                        lastConnectedAt: Date(),
                        avgResponseTime: 520,
                        failureCount: 3,
                        authRequired: false,
                        paymentRequired: true
                    ))
                ]),
                fetchedAt: Date(),
                source: .nip65
            ),
            displayName: "jack"
        )
        OutboxUserDetailView(entry: mockEntry)
            .preferredColorScheme(.dark)
    }
}
</file>

<file path="Sources/Ambulando/Views/AccountSectionView.swift">
import SwiftUI
import NDKSwift
struct AccountSectionView: View {
    let currentUser: NDKUser?
    let userProfile: NDKUserProfile?
    let copiedNpub: Bool
    let onCopyNpub: (String) -> Void
    var body: some View {
        Section {
            if let currentUser = currentUser {
                HStack {
                    // Profile picture placeholder
                    Circle()
                        .fill(
                            LinearGradient(
                                gradient: Gradient(colors: [
                                    Color.purple,
                                    Color.blue
                                ]),
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .overlay(
                            Text((userProfile?.displayName ?? userProfile?.name ?? "User").prefix(1).uppercased())
                                .font(.headline)
                                .foregroundColor(.white)
                        )
                        .frame(width: 50, height: 50)
                    VStack(alignment: .leading, spacing: 4) {
                        Text(userProfile?.displayName ?? userProfile?.name ?? "Nostr User")
                            .font(.headline)
                            .foregroundColor(.white)
                        HStack(spacing: 4) {
                            Text(String(currentUser.npub.prefix(16)) + "...")
                                .font(.caption)
                                .foregroundStyle(Color.white.opacity(0.6))
                            Button(action: { onCopyNpub(currentUser.npub) }) {
                                Image(systemName: copiedNpub ? "checkmark.circle.fill" : "doc.on.doc")
                                    .font(.caption)
                                    .foregroundColor(copiedNpub ? .green : Color.white.opacity(0.6))
                            }
                            .buttonStyle(.plain)
                        }
                    }
                    Spacer()
                }
            } else {
                Text("No user logged in")
                    .foregroundStyle(Color.white.opacity(0.6))
            }
        } header: {
            Text("Account")
                .foregroundColor(Color.white.opacity(0.8))
        }
        .listRowBackground(Color.white.opacity(0.05))
    }
}
</file>

<file path="Sources/Ambulando/Views/AudioEventCard.swift">
import SwiftUI
import NDKSwift
import NDKSwiftUI
import AVFoundation
struct AudioEventCard: View {
    let audioEvent: AudioEvent
    @EnvironmentObject var appState: AppState
    @EnvironmentObject var nostrManager: NostrManager
    @State private var author: NDKUserProfile?
    @State private var replyToProfile: NDKUserProfile?
    @State private var isPlaying = false
    @State private var playbackProgress: Double = 0
    @State private var duration: TimeInterval = 0
    @State private var audioPlayer: AVPlayer?
    @State private var timeObserver: Any?
    // Reaction states
    @State private var reactionsByEmoji: [String: [NDKEvent]] = [:]
    @State private var userReactions: Set<String> = []
    @State private var showingReactionPopover = false
    @State private var showingReactionsDrawer = false
    @State private var selectedReactionEmoji: String?
    @State private var cardScale: CGFloat = 1
    @State private var showingUserProfile = false
    var isCurrentlyPlaying: Bool {
        appState.currentlyPlayingId == audioEvent.id && isPlaying
    }
    var body: some View {
        HStack(alignment: .top, spacing: 13) {
            // Author avatar using NDKSwiftUI component
            NDKProfilePicture(pubkey: audioEvent.author.pubkey, size: 44)
                .onTapGesture {
                    showingUserProfile = true
                }
            VStack(alignment: .leading, spacing: 5) {
                // Author info
                HStack(spacing: 4) {
                    Text(author?.displayName ?? author?.name ?? String(audioEvent.author.pubkey.prefix(8)))
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundColor(.white)
                        .lineLimit(1)
                        .onTapGesture {
                            showingUserProfile = true
                        }
                    if audioEvent.webOfTrustScore >= 0.8 {
                        Image(systemName: "checkmark.seal.fill")
                            .font(.system(size: 12))
                            .foregroundColor(.purple)
                    }
                    Text("•")
                        .font(.system(size: 11))
                        .foregroundColor(Color.white.opacity(0.4))
                    Text(relativeTime(from: audioEvent.createdAt))
                        .font(.system(size: 12))
                        .foregroundColor(Color.white.opacity(0.6))
                    Spacer()
                }
                // Reply indicator
                if audioEvent.isReply {
                    HStack(spacing: 4) {
                        Image(systemName: "arrowshape.turn.up.left.fill")
                            .font(.system(size: 10))
                        if let replyToProfile = replyToProfile {
                            Text("Replying to \(replyToProfile.displayName ?? replyToProfile.name ?? String(audioEvent.replyToPubkey?.prefix(8) ?? ""))")
                                .font(.system(size: 12))
                        } else if let replyToPubkey = audioEvent.replyToPubkey {
                            Text("Replying to \(String(replyToPubkey.prefix(8)))...")
                                .font(.system(size: 12))
                        } else {
                            Text("Reply")
                                .font(.system(size: 12))
                        }
                    }
                    .foregroundColor(Color.white.opacity(0.5))
                }
                // Audio player
                AudioPlayerView(
                    isPlaying: $isPlaying,
                    progress: $playbackProgress,
                    duration: duration,
                    waveform: audioEvent.waveform,
                    onPlayPause: togglePlayback,
                    onSeek: seek
                )
                // Hashtags
                if !audioEvent.hashtags.isEmpty {
                    HashtagsView(hashtags: audioEvent.hashtags)
                        .padding(.top, 8)
                }
                // Reactions bar
                HStack(spacing: 16) {
                    // Reaction button
                    Button(action: { showingReactionPopover = true }) {
                        Image(systemName: userReactions.isEmpty ? "face.smiling" : "face.smiling.fill")
                            .font(.system(size: 16))
                            .foregroundColor(userReactions.isEmpty ? Color.white.opacity(0.5) : .yellow)
                    }
                    .popover(isPresented: $showingReactionPopover) {
                        ReactionPopover(onReaction: handleReaction)
                    }
                    // Reaction pills
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 8) {
                            ForEach(reactionsByEmoji.keys.sorted(), id: \.self) { emoji in
                                ReactionPill(
                                    emoji: emoji,
                                    count: reactionsByEmoji[emoji]?.count ?? 0,
                                    isSelected: userReactions.contains(emoji),
                                    onTap: {
                                        selectedReactionEmoji = emoji
                                        showingReactionsDrawer = true
                                    }
                                )
                            }
                        }
                    }
                    .frame(maxWidth: 200)
                    Button(action: { 
                        appState.replyingTo = audioEvent
                    }) {
                        Image(systemName: "bubble.left")
                            .font(.system(size: 16))
                            .foregroundColor(Color.white.opacity(0.5))
                    }
                    Spacer()
                }
                .padding(.top, 4)
            }
        }
        .padding(.horizontal, 18)
        .padding(.vertical, 9)
        .background(
            isCurrentlyPlaying ? Color.white.opacity(0.03) : Color.clear
        )
        .onAppear {
            loadAuthorProfile()
            if audioEvent.isReply && audioEvent.replyToPubkey != nil {
                loadReplyToProfile()
            }
            setupAudioPlayer()
            loadReactions()
        }
        .onDisappear {
            cleanup()
        }
        .onChange(of: appState.currentlyPlayingId) { _, newId in
            if newId != audioEvent.id && isPlaying {
                pausePlayback()
            }
        }
        .sheet(isPresented: $showingUserProfile) {
            NavigationView {
                UserProfileView(pubkey: audioEvent.author.pubkey)
            }
        }
        .sheet(isPresented: $showingReactionsDrawer) {
            if let emoji = selectedReactionEmoji {
                ReactionsDrawer(
                    emoji: emoji,
                    reactions: reactionsByEmoji[emoji] ?? [],
                    nostrManager: nostrManager
                )
            }
        }
    }
    private func loadAuthorProfile() {
        Task {
            guard let ndk = nostrManager.ndk else { return }
            for await profile in await ndk.profileManager.observe(for: audioEvent.author.pubkey, maxAge: TimeConstants.hour) {
                await MainActor.run {
                    self.author = profile
                }
                break // Just get the first result
            }
        }
    }
    private func loadReplyToProfile() {
        Task {
            guard let ndk = nostrManager.ndk,
                  let replyToPubkey = audioEvent.replyToPubkey else { return }
            for await profile in await ndk.profileManager.observe(for: replyToPubkey, maxAge: TimeConstants.hour) {
                await MainActor.run {
                    self.replyToProfile = profile
                }
                break // Just get the first result
            }
        }
    }
    private func setupAudioPlayer() {
        guard let url = URL(string: audioEvent.audioURL) else { return }
        // Configure audio session for proper Bluetooth support
        let audioSession = AVAudioSession.sharedInstance()
        do {
            try audioSession.setCategory(.playback, mode: .default, options: [.allowBluetooth, .allowAirPlay])
            try audioSession.setActive(true)
        } catch {
            print("Failed to configure audio session: \(error)")
        }
        let playerItem = AVPlayerItem(url: url)
        audioPlayer = AVPlayer(playerItem: playerItem)
        // Use pre-loaded duration from imeta if available, otherwise load from asset
        if let metadataDuration = audioEvent.duration {
            self.duration = metadataDuration
        } else {
            // Get duration
            Task {
                let duration = try await playerItem.asset.load(.duration)
                await MainActor.run {
                    self.duration = duration.seconds
                }
            }
        }
        // Observe playback progress
        let interval = CMTime(seconds: 0.1, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
        timeObserver = audioPlayer?.addPeriodicTimeObserver(forInterval: interval, queue: .main) { time in
            guard let duration = audioPlayer?.currentItem?.duration else { return }
            let currentTime = time.seconds
            let totalTime = duration.seconds
            if totalTime > 0 {
                playbackProgress = currentTime / totalTime
            }
            // Check if playback ended
            if currentTime >= totalTime - 0.1 {
                pausePlayback()
                // Reset progress to 1 to indicate playback has completed
                playbackProgress = 1.0
            }
        }
    }
    private func togglePlayback() {
        if isPlaying {
            pausePlayback()
        } else {
            startPlayback()
        }
    }
    private func startPlayback() {
        // Stop any other playing audio
        appState.currentlyPlayingId = audioEvent.id
        // Seek to beginning if playback has ended or progress is near the end
        if let duration = audioPlayer?.currentItem?.duration {
            let currentTime = audioPlayer?.currentTime() ?? CMTime.zero
            let totalTime = duration.seconds
            let currentSeconds = currentTime.seconds
            // If we're at the end (within last 0.5 seconds) or past the end, seek to beginning
            if currentSeconds >= totalTime - 0.5 || playbackProgress >= 0.99 {
                audioPlayer?.seek(to: CMTime.zero) { _ in
                    self.playbackProgress = 0
                }
            }
        }
        audioPlayer?.play()
        isPlaying = true
        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
            cardScale = 1.02
        }
    }
    private func pausePlayback() {
        audioPlayer?.pause()
        isPlaying = false
        if appState.currentlyPlayingId == audioEvent.id {
            appState.currentlyPlayingId = nil
        }
        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
            cardScale = 1
        }
    }
    private func seek(to progress: Double) {
        guard let duration = audioPlayer?.currentItem?.duration,
              duration.isValid,
              duration.isNumeric,
              !duration.isIndefinite else { return }
        let targetTime = CMTime(seconds: progress * duration.seconds, preferredTimescale: duration.timescale)
        audioPlayer?.seek(to: targetTime)
    }
    private func cleanup() {
        if let observer = timeObserver {
            audioPlayer?.removeTimeObserver(observer)
        }
        audioPlayer = nil
    }
    private func relativeTime(from date: Date) -> String {
        let interval = Date().timeIntervalSince(date)
        if interval < TimeConstants.minute {
            return "now"
        } else if interval < TimeConstants.hour {
            let minutes = Int(interval / TimeConstants.minute)
            return "\(minutes)m"
        } else if interval < TimeConstants.day {
            let hours = Int(interval / TimeConstants.hour)
            return "\(hours)h"
        } else {
            let days = Int(interval / TimeConstants.day)
            return "\(days)d"
        }
    }
    private func formattedDuration(_ duration: TimeInterval) -> String {
        let totalSeconds = Int(duration)
        if totalSeconds < Int(TimeConstants.minute) {
            return "\(totalSeconds)s"
        } else {
            let minutes = totalSeconds / Int(TimeConstants.minute)
            let seconds = totalSeconds % Int(TimeConstants.minute)
            return String(format: "%d:%02d", minutes, seconds)
        }
    }
    private func loadReactions() {
        Task {
            guard let ndk = nostrManager.ndk else { return }
            // Load reactions specifically for this event using #e tag
            let filter = NDKFilter(
                kinds: [7],
                tags: ["e": [audioEvent.id]]
            )
            let dataSource = ndk.observe(filter: filter, maxAge: 0)
            for await event in dataSource.events {
                // Process all emoji reactions
                let emoji = normalizeReactionEmoji(event.content)
                if isValidReactionEmoji(emoji) {
                    await MainActor.run {
                        // Group reactions by emoji
                        if reactionsByEmoji[emoji] == nil {
                            reactionsByEmoji[emoji] = []
                        }
                        // Add if not already present
                        if !reactionsByEmoji[emoji]!.contains(where: { $0.id == event.id }) {
                            reactionsByEmoji[emoji]!.append(event)
                            // Check if current user has reacted with this emoji
                            if let currentUserPubkey = appState.currentUser?.pubkey,
                               event.pubkey == currentUserPubkey {
                                userReactions.insert(emoji)
                            }
                        }
                    }
                }
            }
        }
    }
    private func normalizeReactionEmoji(_ content: String) -> String {
        // Map common variations to standard emojis
        switch content {
        case "+", "👍": return "👍"
        case "❤️", "♥️": return "❤️"
        case "🤙": return "🤙"
        default: return content
        }
    }
    private func isValidReactionEmoji(_ emoji: String) -> Bool {
        // Only allow single emoji characters or + symbol
        if emoji == "+" || emoji == "👍" { return true }
        // Check if it's a single emoji
        let scalars = emoji.unicodeScalars
        guard scalars.count >= 1 else { return false }
        // Simple emoji validation
        return emoji.count <= 4 && emoji.containsEmoji
    }
    private func handleReaction(_ emoji: String) {
        guard let ndk = nostrManager.ndk else { return }
        Task {
            if userReactions.contains(emoji) {
                // Already reacted with this emoji
                return
            }
            do {
                // Use NDKEventBuilder to create and publish reaction
                let (_, _) = try await ndk.publish { builder in
                    builder
                        .kind(7)  // Reaction event
                        .content(emoji)
                        .tag(["e", audioEvent.id])
                        .tag(["p", audioEvent.author.pubkey])
                }
                await MainActor.run {
                    userReactions.insert(emoji)
                    showingReactionPopover = false
                }
            } catch {
                print("Failed to publish reaction: \(error)")
            }
        }
    }
}
// MARK: - Audio Player View
struct AudioPlayerView: View {
    @Binding var isPlaying: Bool
    @Binding var progress: Double
    let duration: TimeInterval
    let waveform: [Double]?
    let onPlayPause: () -> Void
    let onSeek: (Double) -> Void
    @State private var isDragging = false
    @State private var dragProgress: Double = 0
    var displayProgress: Double {
        isDragging ? dragProgress : progress
    }
    var remainingTime: String {
        let remainingSeconds = Int(duration * (1 - displayProgress))
        let minutes = remainingSeconds / 60
        let seconds = remainingSeconds % 60
        return String(format: "%d:%02d", minutes, seconds)
    }
    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                // Background with waveform or simple capsule
                if let waveform = waveform, !waveform.isEmpty {
                    // Waveform visualization
                    HStack(spacing: 1) {
                        ForEach(0..<waveform.count, id: \.self) { index in
                            let barHeight = 8 + (waveform[index] * 20) // Min 8, max 28
                            let progressPosition = Double(index) / Double(waveform.count - 1)
                            let isPassed = progressPosition <= displayProgress
                            Capsule()
                                .fill(
                                    isPassed ?
                                    LinearGradient(
                                        gradient: Gradient(colors: [
                                            Color.purple.opacity(0.7),
                                            Color.blue.opacity(0.5)
                                        ]),
                                        startPoint: .top,
                                        endPoint: .bottom
                                    ) :
                                    LinearGradient(
                                        gradient: Gradient(colors: [
                                            Color.white.opacity(0.15),
                                            Color.white.opacity(0.08)
                                        ]),
                                        startPoint: .top,
                                        endPoint: .bottom
                                    )
                                )
                                .frame(width: max(1, geometry.size.width / CGFloat(waveform.count) - 1), 
                                       height: barHeight)
                        }
                    }
                    .frame(height: 36)
                } else {
                    // Fallback to simple progress bar
                    Capsule()
                        .fill(Color.white.opacity(0.08))
                        .frame(height: 36)
                    // Progress
                    Capsule()
                        .fill(
                            LinearGradient(
                                gradient: Gradient(colors: [
                                    Color.purple.opacity(0.7),
                                    Color.blue.opacity(0.5)
                                ]),
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .frame(width: geometry.size.width * displayProgress, height: 36)
                }
                // Content overlay
                HStack {
                    // Play/Pause button integrated
                    Button(action: onPlayPause) {
                        Image(systemName: isPlaying ? "pause.fill" : "play.fill")
                            .font(.system(size: 15))
                            .foregroundColor(.white)
                            .frame(width: 31, height: 31)
                            .background(
                                Circle()
                                    .fill(Color.black.opacity(0.3))
                            )
                    }
                    .padding(.leading, 4)
                    Spacer()
                    // Remaining time
                    if duration > 0 {
                        Text(remainingTime)
                            .font(.system(size: 12, weight: .medium, design: .monospaced))
                            .foregroundColor(.white)
                            .padding(.trailing, 12)
                    }
                }
            }
            .gesture(
                DragGesture(minimumDistance: 0)
                    .onChanged { value in
                        // Only allow dragging if duration is valid
                        if duration > 0 {
                            isDragging = true
                            dragProgress = min(max(0, value.location.x / geometry.size.width), 1)
                        }
                    }
                    .onEnded { _ in
                        // Only seek if duration is valid
                        if duration > 0 {
                            isDragging = false
                            onSeek(dragProgress)
                        }
                    }
            )
        }
        .frame(height: 40)
    }
}
// MARK: - Reaction Components
struct ReactionPopover: View {
    let onReaction: (String) -> Void
    @Environment(\.dismiss) private var dismiss
    let reactionEmojis = ["👍", "❤️", "😂", "🔥", "🤙", "⚡️", "💜", "🤔", "😍", "💯"]
    var body: some View {
        VStack(spacing: 0) {
            Text("React")
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(.white.opacity(0.7))
                .padding(.top, 12)
                .padding(.bottom, 8)
            LazyVGrid(columns: [GridItem(.adaptive(minimum: 44))], spacing: 8) {
                ForEach(reactionEmojis, id: \.self) { emoji in
                    Button(action: {
                        onReaction(emoji)
                        dismiss()
                    }) {
                        Text(emoji)
                            .font(.system(size: 28))
                            .frame(width: 44, height: 44)
                            .background(
                                Circle()
                                    .fill(Color.white.opacity(0.08))
                            )
                    }
                    .buttonStyle(PlainButtonStyle())
                }
            }
            .padding(.horizontal, 12)
            .padding(.bottom, 12)
        }
        .frame(width: 240)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color(UIColor.systemGray6))
        )
        .preferredColorScheme(.dark)
    }
}
struct ReactionPill: View {
    let emoji: String
    let count: Int
    let isSelected: Bool
    let onTap: () -> Void
    private var pillBackground: LinearGradient {
        if isSelected {
            return LinearGradient(
                gradient: Gradient(colors: [Color.purple.opacity(0.6), Color.blue.opacity(0.4)]),
                startPoint: .leading,
                endPoint: .trailing
            )
        } else {
            return LinearGradient(
                gradient: Gradient(colors: [Color.white.opacity(0.08), Color.white.opacity(0.05)]),
                startPoint: .leading,
                endPoint: .trailing
            )
        }
    }
    var body: some View {
        Button(action: onTap) {
            HStack(spacing: 4) {
                Text(emoji)
                    .font(.system(size: 14))
                Text("\(count)")
                    .font(.system(size: 12, weight: .medium))
                    .foregroundColor(isSelected ? .white : .white.opacity(0.7))
            }
            .padding(.horizontal, 10)
            .padding(.vertical, 4)
            .background(
                Capsule()
                    .fill(pillBackground)
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}
struct ReactionsDrawer: View {
    let emoji: String
    let reactions: [NDKEvent]
    let nostrManager: NostrManager
    @Environment(\.dismiss) private var dismiss
    @State private var profiles: [String: NDKUserProfile] = [:]
    var body: some View {
        NavigationView {
            ZStack {
                Color.black.ignoresSafeArea()
                ScrollView {
                    VStack(spacing: 0) {
                        headerSection
                        Divider()
                            .background(Color.white.opacity(0.1))
                        reactionsList
                    }
                }
            }
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(.white)
                }
            }
        }
        .onAppear {
            loadProfiles()
        }
    }
    private var headerSection: some View {
        VStack(spacing: 8) {
            Text(emoji)
                .font(.system(size: 60))
                .padding(.top, 20)
            Text("\(reactions.count) reaction\(reactions.count == 1 ? "" : "s")")
                .font(.system(size: 16))
                .foregroundColor(.white.opacity(0.6))
                .padding(.bottom, 12)
        }
    }
    private var reactionsList: some View {
        LazyVStack(spacing: 0) {
            ForEach(reactions, id: \.id) { reaction in
                reactionRow(for: reaction)
                Divider()
                    .background(Color.white.opacity(0.1))
            }
        }
    }
    private func reactionRow(for reaction: NDKEvent) -> some View {
        HStack(spacing: 12) {
            NDKProfilePicture(pubkey: reaction.pubkey, size: 40)
            profileInfo(for: reaction.pubkey)
            Spacer()
            Text(relativeTime(from: Date(timeIntervalSince1970: TimeInterval(reaction.createdAt))))
                .font(.system(size: 12))
                .foregroundColor(.white.opacity(0.4))
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
    }
    private func profileInfo(for pubkey: String) -> some View {
        VStack(alignment: .leading, spacing: 2) {
            if let profile = profiles[pubkey] {
                Text(profile.displayName ?? profile.name ?? String(pubkey.prefix(8)))
                    .font(.system(size: 15, weight: .semibold))
                    .foregroundColor(.white)
                    .lineLimit(1)
                if let name = profile.name, profile.displayName != nil {
                    Text("@\(name)")
                        .font(.system(size: 13))
                        .foregroundColor(.white.opacity(0.5))
                        .lineLimit(1)
                }
            } else {
                Text(String(pubkey.prefix(8)) + "...")
                    .font(.system(size: 15, weight: .semibold))
                    .foregroundColor(.white)
            }
        }
    }
    private func loadProfiles() {
        Task {
            guard let ndk = nostrManager.ndk else { return }
            for reaction in reactions {
                for await profile in await ndk.profileManager.observe(for: reaction.pubkey, maxAge: TimeConstants.hour) {
                    await MainActor.run {
                        profiles[reaction.pubkey] = profile
                    }
                    break
                }
            }
        }
    }
    private func relativeTime(from date: Date) -> String {
        let interval = Date().timeIntervalSince(date)
        if interval < TimeConstants.minute {
            return "now"
        } else if interval < TimeConstants.hour {
            let minutes = Int(interval / TimeConstants.minute)
            return "\(minutes)m"
        } else if interval < TimeConstants.day {
            let hours = Int(interval / TimeConstants.hour)
            return "\(hours)h"
        } else {
            let days = Int(interval / TimeConstants.day)
            return "\(days)d"
        }
    }
}
// MARK: - Hashtags View
struct HashtagsView: View {
    let hashtags: [String]
    var body: some View {
        LazyVGrid(columns: [GridItem(.adaptive(minimum: 60), spacing: 8)], alignment: .leading, spacing: 6) {
            ForEach(hashtags, id: \.self) { hashtag in
                HashtagPill(hashtag: hashtag)
            }
        }
    }
}
struct HashtagPill: View {
    let hashtag: String
    var body: some View {
        Text("#\(hashtag)")
            .font(.system(size: 12, weight: .medium))
            .foregroundColor(.purple)
            .padding(.horizontal, 8)
            .padding(.vertical, 4)
            .background(
                Capsule()
                    .fill(Color.purple.opacity(0.1))
                    .overlay(
                        Capsule()
                            .stroke(Color.purple.opacity(0.3), lineWidth: 0.5)
                    )
            )
    }
}
// MARK: - String Extension
extension String {
    var containsEmoji: Bool {
        for scalar in unicodeScalars {
            switch scalar.value {
            case 0x1F600...0x1F64F, // Emoticons
                 0x1F300...0x1F5FF, // Misc Symbols and Pictographs
                 0x1F680...0x1F6FF, // Transport and Map
                 0x1F700...0x1F77F, // Alchemical Symbols
                 0x1F780...0x1F7FF, // Geometric Shapes Extended
                 0x1F800...0x1F8FF, // Supplemental Arrows-C
                 0x2600...0x26FF,   // Misc symbols
                 0x2700...0x27BF,   // Dingbats
                 0xFE00...0xFE0F,   // Variation Selectors
                 0x1F900...0x1F9FF, // Supplemental Symbols and Pictographs
                 0x1FA00...0x1FA6F, // Chess Symbols
                 0x1FA70...0x1FAFF: // Symbols and Pictographs Extended-A
                return true
            default:
                continue
            }
        }
        return false
    }
}
</file>

<file path="Sources/Ambulando/Views/AuthenticationView.swift">
import SwiftUI
import NDKSwift
struct AuthenticationView: View {
    @EnvironmentObject var nostrManager: NostrManager
    @EnvironmentObject var appState: AppState
    @Environment(\.colorScheme) private var colorScheme
    // Animation states
    @State private var logoScale: CGFloat = 0.3
    @State private var logoOpacity: Double = 0
    @State private var logoRotation: Double = -180
    @State private var titleOffset: CGFloat = 50
    @State private var titleOpacity: Double = 0
    @State private var sloganOpacity: Double = 0
    @State private var sloganScale: CGFloat = 0.8
    @State private var pulseScale: CGFloat = 1
    @State private var glowOpacity: Double = 0
    @State private var electricityOffset: CGFloat = -100
    @State private var buttonsOffset: CGFloat = 100
    @State private var buttonsOpacity: Double = 0
    // Auth states
    @State private var showingLogin = false
    @State private var authInput = ""
    @State private var showPassword = false
    @State private var isLoggingIn = false
    @State private var errorMessage = ""
    @State private var showError = false
    @State private var showingQRScanner = false
    @State private var isConnectingToBunker = false
    var body: some View {
        ZStack {
            // Electric field effect
            ForEach(0..<5) { index in
                ElectricArc(
                    startPoint: CGPoint(x: 0.5, y: 0.5),
                    endPoint: CGPoint(
                        x: 0.5 + cos(Double(index) * .pi / 2.5) * 0.4,
                        y: 0.5 + sin(Double(index) * .pi / 2.5) * 0.4
                    )
                )
                .stroke(
                    LinearGradient(
                        gradient: Gradient(colors: [
                            Color.purple.opacity(0.6),
                            Color.blue.opacity(0.3),
                            Color.clear
                        ]),
                        startPoint: .center,
                        endPoint: .bottom
                    ),
                    lineWidth: 2
                )
                .blur(radius: 3)
                .opacity(showingLogin ? glowOpacity * 0.3 : glowOpacity)
                .offset(y: electricityOffset)
                .animation(
                    .easeInOut(duration: 2)
                    .delay(Double(index) * 0.1)
                    .repeatForever(autoreverses: true),
                    value: electricityOffset
                )
            }
            if !showingLogin {
                // Initial welcome screen
                VStack(spacing: 40) {
                    Spacer()
                    // Logo and title
                    ZStack {
                        // Outer pulsing glow
                        FootprintShape()
                            .fill(
                                RadialGradient(
                                    gradient: Gradient(colors: [
                                        Color.purple.opacity(0.8),
                                        Color.blue.opacity(0.4),
                                        Color.clear
                                    ]),
                                    center: .center,
                                    startRadius: 10,
                                    endRadius: 120
                                )
                            )
                            .frame(width: 280, height: 320)
                            .blur(radius: 30)
                            .scaleEffect(pulseScale)
                            .opacity(logoOpacity * 0.7)
                        // Logo background footprint
                        FootprintShape()
                            .fill(
                                LinearGradient(
                                    gradient: Gradient(colors: [
                                        Color.purple,
                                        Color.purple.opacity(0.9),
                                        Color(red: 0.4, green: 0.1, blue: 0.8)
                                    ]),
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .frame(width: 140, height: 160)
                            .shadow(color: Color.purple.opacity(0.5), radius: 20, x: 0, y: 5)
                            .scaleEffect(logoScale)
                            .opacity(logoOpacity)
                            .rotationEffect(.degrees(logoRotation))
                        // Logo icon
                        Image(systemName: "waveform.circle.fill")
                            .font(.system(size: 80))
                            .foregroundColor(.white)
                            .scaleEffect(logoScale)
                            .opacity(logoOpacity)
                            .rotationEffect(.degrees(logoRotation))
                    }
                    // Title
                    Text("AMBULANDO")
                        .font(.system(size: 52, weight: .black, design: .default))
                        .tracking(4)
                        .foregroundStyle(
                            LinearGradient(
                                gradient: Gradient(colors: [
                                    Color.white,
                                    Color.white.opacity(0.9)
                                ]),
                                startPoint: .top,
                                endPoint: .bottom
                            )
                        )
                        .shadow(color: Color.purple.opacity(0.3), radius: 10, x: 0, y: 2)
                        .opacity(titleOpacity)
                        .offset(y: titleOffset)
                    // Slogan
                    Text("JOURNEY THROUGH VOICE")
                        .font(.system(size: 16, weight: .medium, design: .monospaced))
                        .tracking(2)
                        .foregroundColor(Color.white.opacity(0.7))
                        .scaleEffect(sloganScale)
                        .opacity(sloganOpacity)
                    Spacer()
                    // Login buttons
                    VStack(spacing: 16) {
                        Button(action: { 
                            withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {
                                showingLogin = true 
                            }
                        }) {
                            HStack {
                                Image(systemName: "key.fill")
                                    .font(.system(size: 20))
                                Text("Login")
                                    .font(.system(size: 18, weight: .semibold))
                            }
                            .frame(maxWidth: .infinity)
                            .frame(height: 56)
                            .background(
                                LinearGradient(
                                    gradient: Gradient(colors: [
                                        Color.purple,
                                        Color(red: 0.5, green: 0.1, blue: 0.9)
                                    ]),
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                            .foregroundColor(.white)
                            .clipShape(RoundedRectangle(cornerRadius: 16))
                            .shadow(color: Color.purple.opacity(0.3), radius: 10, x: 0, y: 4)
                        }
                        Text("Login with nsec or NIP-46")
                            .font(.system(size: 14, weight: .medium))
                            .foregroundColor(Color.white.opacity(0.4))
                            .padding(.top, 8)
                    }
                    .padding(.horizontal, 32)
                    .offset(y: buttonsOffset)
                    .opacity(buttonsOpacity)
                    Spacer()
                        .frame(height: 60)
                }
            } else {
                // Login form
                loginForm
                    .transition(.asymmetric(
                        insertion: .move(edge: .trailing).combined(with: .opacity),
                        removal: .move(edge: .leading).combined(with: .opacity)
                    ))
            }
        }
        .sheet(isPresented: $showingQRScanner) {
            QRScannerView { scannedCode in
                authInput = scannedCode
                showingQRScanner = false
            } onDismiss: {
                showingQRScanner = false
            }
        }
        .alert("Error", isPresented: $showError) {
            Button("OK") { }
        } message: {
            Text(errorMessage)
        }
        .onAppear {
            animateIntro()
        }
    }
    private var loginForm: some View {
        GeometryReader { geometry in
            ScrollView {
                VStack(spacing: 0) {
                    // Navigation bar
                    HStack {
                        Button(action: {
                            withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {
                                showingLogin = false
                                authInput = ""
                                showPassword = false
                            }
                        }) {
                            HStack(spacing: 8) {
                                Image(systemName: "chevron.left")
                                    .font(.system(size: 18, weight: .medium))
                                Text("Back")
                                    .font(.system(size: 16, weight: .medium))
                            }
                            .foregroundColor(Color.purple)
                        }
                        Spacer()
                    }
                    .padding(.horizontal, 20)
                    .padding(.top, 60) // Account for safe area
                    .padding(.bottom, 30)
                    // Logo section - smaller and properly positioned
                    ZStack {
                        // Glow effect
                        FootprintShape()
                            .fill(
                                RadialGradient(
                                    gradient: Gradient(colors: [
                                        Color.purple.opacity(0.4),
                                        Color.blue.opacity(0.2),
                                        Color.clear
                                    ]),
                                    center: .center,
                                    startRadius: 5,
                                    endRadius: 50
                                )
                            )
                            .frame(width: 120, height: 135)
                            .blur(radius: 20)
                        // Logo background
                        FootprintShape()
                            .fill(
                                LinearGradient(
                                    gradient: Gradient(colors: [
                                        Color.purple,
                                        Color.purple.opacity(0.9),
                                        Color(red: 0.4, green: 0.1, blue: 0.8)
                                    ]),
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .frame(width: 80, height: 90)
                            .shadow(color: Color.purple.opacity(0.3), radius: 10, x: 0, y: 3)
                        // Logo icon
                        Image(systemName: "waveform.circle.fill")
                            .font(.system(size: 45))
                            .foregroundColor(.white)
                    }
                    .padding(.bottom, 40)
                    // Content section
                    VStack(spacing: 30) {
                        VStack(spacing: 12) {
                            Text("Welcome Back")
                                .font(.system(size: 28, weight: .bold))
                                .foregroundColor(.white)
                            Text("Enter your private key or scan QR code")
                                .font(.system(size: 16))
                                .foregroundColor(Color.white.opacity(0.7))
                        }
                        // Input section
                        VStack(spacing: 24) {
                            VStack(alignment: .leading, spacing: 10) {
                                Text("Login Credentials")
                                    .font(.system(size: 15, weight: .medium))
                                    .foregroundColor(Color.white.opacity(0.9))
                                HStack {
                                    if showPassword {
                                        TextField("nsec1... or bunker://...", text: $authInput)
                                            .textContentType(.password)
                                            .textInputAutocapitalization(.never)
                                            .font(.system(.body, design: .monospaced))
                                    } else {
                                        SecureField("nsec1... or bunker://...", text: $authInput)
                                            .textContentType(.password)
                                            .textInputAutocapitalization(.never)
                                            .font(.system(.body, design: .monospaced))
                                    }
                                    Button(action: { showPassword.toggle() }) {
                                        Image(systemName: showPassword ? "eye.slash.fill" : "eye.fill")
                                            .font(.system(size: 16))
                                            .foregroundColor(Color.white.opacity(0.6))
                                    }
                                    Button(action: { showingQRScanner = true }) {
                                        Image(systemName: "qrcode.viewfinder")
                                            .font(.system(size: 20))
                                            .foregroundColor(Color.white.opacity(0.8))
                                    }
                                }
                                .padding(18)
                                .background(Color.white.opacity(0.08))
                                .foregroundColor(.white)
                                .accentColor(.purple)
                                .overlay(
                                    RoundedRectangle(cornerRadius: 12)
                                        .stroke(Color.white.opacity(0.2), lineWidth: 1)
                                )
                                .clipShape(RoundedRectangle(cornerRadius: 12))
                                HStack {
                                    Image(systemName: "lock.shield.fill")
                                        .font(.system(size: 12))
                                        .foregroundColor(Color.white.opacity(0.5))
                                    Text("Your key is stored securely on this device")
                                        .font(.system(size: 13))
                                        .foregroundColor(Color.white.opacity(0.5))
                                }
                                .padding(.top, 2)
                            }
                            // Login button
                            Button(action: login) {
                                ZStack {
                                    if isLoggingIn {
                                        HStack(spacing: 12) {
                                            ProgressView()
                                                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                                .scaleEffect(0.9)
                                            Text("Logging in...")
                                                .fontWeight(.semibold)
                                        }
                                    } else {
                                        HStack {
                                            Image(systemName: "arrow.right.circle.fill")
                                            Text("Log In")
                                                .fontWeight(.semibold)
                                        }
                                    }
                                }
                                .foregroundColor(.white)
                                .frame(maxWidth: .infinity)
                                .frame(height: 56)
                                .background(
                                    LinearGradient(
                                        gradient: Gradient(colors: [
                                            authInput.isEmpty ? Color.gray : Color.purple,
                                            authInput.isEmpty ? Color.gray.opacity(0.8) : Color(red: 0.5, green: 0.1, blue: 0.9)
                                        ]),
                                        startPoint: .leading,
                                        endPoint: .trailing
                                    )
                                )
                                .clipShape(RoundedRectangle(cornerRadius: 16))
                                .shadow(color: authInput.isEmpty ? Color.clear : Color.purple.opacity(0.3), radius: 10, x: 0, y: 4)
                                .disabled(authInput.isEmpty || isLoggingIn)
                            }
                        }
                        .padding(.horizontal, 32)
                    }
                    // Bottom padding to ensure content is above keyboard
                    Spacer(minLength: 50)
                }
                .frame(minHeight: geometry.size.height)
            }
            .scrollDismissesKeyboard(.interactively)
        }
    }
    private func animateIntro() {
        // Logo animation with rotation
        withAnimation(.spring(response: 1.2, dampingFraction: 0.7)) {
            logoScale = 1
            logoOpacity = 1
            logoRotation = 0
        }
        // Glow effects
        withAnimation(.easeInOut(duration: 1.5).delay(0.2)) {
            glowOpacity = 0.8
        }
        // Start electricity animation
        withAnimation(.easeInOut(duration: 2).delay(0.5).repeatForever(autoreverses: true)) {
            electricityOffset = 100
        }
        // Title animation
        withAnimation(.easeOut(duration: 0.8).delay(0.8)) {
            titleOffset = 0
            titleOpacity = 1
        }
        // Slogan animation
        withAnimation(.easeOut(duration: 0.8).delay(1.2)) {
            sloganOpacity = 1
            sloganScale = 1
        }
        // Pulse animation
        withAnimation(.easeInOut(duration: 1.5).delay(1).repeatForever(autoreverses: true)) {
            pulseScale = 1.1
        }
        // Button slide up animation
        withAnimation(.spring(response: 0.8, dampingFraction: 0.8).delay(2.0)) {
            buttonsOffset = 0
            buttonsOpacity = 1
        }
    }
    private func login() {
        isLoggingIn = true
        Task {
            do {
                // Check if it's an nsec or NIP-46 payload
                if authInput.starts(with: "nsec") {
                    // Handle nsec login
                    let signer = try NDKPrivateKeySigner(nsec: authInput)
                    let sessionData = try await nostrManager.login(with: signer)
                    await MainActor.run {
                        appState.isAuthenticated = true
                        appState.currentUser = nostrManager.ndk?.getUser(sessionData.pubkey)
                    }
                } else {
                    // Handle NIP-46 login (bunker://, nostrconnect://, or NIP-05)
                    await MainActor.run {
                        isConnectingToBunker = true
                    }
                    guard let ndk = nostrManager.ndk else {
                        throw NDKError.notConfigured("NDK not initialized")
                    }
                    let bunkerSigner: NDKBunkerSigner
                    if authInput.starts(with: "bunker://") {
                        bunkerSigner = try NDKBunkerSigner.bunker(ndk: ndk, connectionToken: authInput)
                    } else if authInput.starts(with: "nostrconnect://") {
                        // Extract relay from nostrconnect URL
                        let components = authInput.replacingOccurrences(of: "nostrconnect://", with: "").split(separator: "?")
                        let relay = components.count > 1 ? String(components[1].split(separator: "=").last ?? "") : "wss://relay.damus.io"
                        bunkerSigner = try NDKBunkerSigner.nostrConnect(ndk: ndk, relay: relay)
                    } else if authInput.contains("@") {
                        // Assume it's a NIP-05
                        bunkerSigner = try NDKBunkerSigner.nip05(ndk: ndk, nip05: authInput)
                    } else {
                        throw NDKError.invalidInput(message: "Invalid login format. Use nsec, bunker://, nostrconnect://, or NIP-05")
                    }
                    // Set the bunker signer on NDK before connecting (critical for NIP-46)
                    ndk.signer = bunkerSigner
                    // Listen for auth URL in case user needs to approve
                    let authUrlTask = Task {
                        for await authUrl in await bunkerSigner.authUrlPublisher.values {
                            await MainActor.run {
                                // Show alert with auth URL
                                errorMessage = "Authorization required! Open this URL in your signer app:\n\n\(authUrl)"
                                showError = true
                            }
                        }
                    }
                    // Connect to the bunker
                    let user = try await bunkerSigner.connect()
                    // Cancel auth URL listener
                    authUrlTask.cancel()
                    // Start session
                    let sessionData = try await nostrManager.login(with: bunkerSigner)
                    await MainActor.run {
                        appState.isAuthenticated = true
                        appState.currentUser = nostrManager.ndk?.getUser(sessionData.pubkey)
                        isConnectingToBunker = false
                    }
                }
            } catch {
                await MainActor.run {
                    errorMessage = error.localizedDescription
                    showError = true
                    isLoggingIn = false
                    isConnectingToBunker = false
                }
            }
        }
    }
}
// MARK: - Electric Arc Shape
struct ElectricArc: Shape {
    let startPoint: CGPoint
    let endPoint: CGPoint
    func path(in rect: CGRect) -> Path {
        var path = Path()
        let start = CGPoint(
            x: startPoint.x * rect.width,
            y: startPoint.y * rect.height
        )
        let end = CGPoint(
            x: endPoint.x * rect.width,
            y: endPoint.y * rect.height
        )
        path.move(to: start)
        // Create a jagged lightning effect
        let segments = 8
        for i in 1...segments {
            let progress = CGFloat(i) / CGFloat(segments)
            let baseX = start.x + (end.x - start.x) * progress
            let baseY = start.y + (end.y - start.y) * progress
            // Add random offset for electric effect
            let offsetRange: CGFloat = 20
            let offsetX = CGFloat.random(in: -offsetRange...offsetRange)
            let offsetY = CGFloat.random(in: -offsetRange...offsetRange)
            let point = CGPoint(x: baseX + offsetX, y: baseY + offsetY)
            if i == segments {
                path.addLine(to: end)
            } else {
                path.addLine(to: point)
            }
        }
        return path
    }
}
</file>

<file path="Sources/Ambulando/Views/BlossomSettingsView.swift">
import SwiftUI
import NDKSwift
struct BlossomSettingsView: View {
    @EnvironmentObject var serverManager: BlossomServerManager
    @State private var newServerUrl = ""
    @State private var showingAddServer = false
    @State private var showingError = false
    @State private var errorMessage = ""
    @Environment(\.dismiss) var dismiss
    init(ndk: NDK?) {
        // Use the serverManager from environment
    }
    var body: some View {
        ZStack {
            Color.black.ignoresSafeArea()
            VStack(spacing: 0) {
                // Header
                HStack {
                    Button("Close") {
                        dismiss()
                    }
                    .foregroundColor(.blue)
                    Spacer()
                    Text("Blossom Servers")
                        .font(.headline)
                        .foregroundColor(.white)
                    Spacer()
                    Button(action: { showingAddServer = true }) {
                        Image(systemName: "plus")
                            .foregroundColor(.blue)
                    }
                }
                .padding()
                .background(Color.gray.opacity(0.1))
                // Server list - always show immediately
                List {
                    ForEach(Array(serverManager.servers.enumerated()), id: \.offset) { index, server in
                        ServerRow(
                            server: server,
                            isPrimary: index == 0,
                            onDelete: {
                                serverManager.removeServer(at: index)
                            }
                        )
                        .listRowBackground(Color.gray.opacity(0.1))
                        .listRowSeparatorTint(.gray.opacity(0.3))
                    }
                    .onMove(perform: { source, destination in
                        serverManager.moveServer(from: source, to: destination)
                    })
                }
                .listStyle(PlainListStyle())
                .scrollContentBackground(.hidden)
                // Instructions
                VStack(alignment: .leading, spacing: 8) {
                    Label("The first server in the list will be used for uploads", systemImage: "info.circle")
                        .font(.caption)
                        .foregroundColor(.gray)
                    Label("Drag to reorder servers", systemImage: "arrow.up.arrow.down")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
                .padding()
                .background(Color.gray.opacity(0.1))
            }
        }
        .preferredColorScheme(.dark)
        .sheet(isPresented: $showingAddServer) {
            AddServerSheet(
                serverUrl: $newServerUrl,
                suggestedServers: serverManager.suggestedServers,
                existingServers: serverManager.servers,
                onAdd: { url in
                    addServer(url)
                    showingAddServer = false
                    newServerUrl = ""
                },
                onCancel: {
                    showingAddServer = false
                    newServerUrl = ""
                }
            )
        }
        .alert("Error", isPresented: $showingError) {
            Button("OK") { }
        } message: {
            Text(errorMessage)
        }
    }
    private func addServer(_ url: String) {
        // Clean up URL
        var cleanUrl = url.trimmingCharacters(in: .whitespacesAndNewlines)
        // Add https:// if no scheme
        if !cleanUrl.hasPrefix("http://") && !cleanUrl.hasPrefix("https://") {
            cleanUrl = "https://\(cleanUrl)"
        }
        // Validate URL
        guard let validUrl = URL(string: cleanUrl),
              validUrl.host != nil else {
            errorMessage = "Invalid server URL"
            showingError = true
            return
        }
        // Check if already exists
        if serverManager.servers.contains(cleanUrl) {
            errorMessage = "Server already exists in the list"
            showingError = true
            return
        }
        serverManager.addServer(cleanUrl)
    }
}
// MARK: - Server Row
struct ServerRow: View {
    let server: String
    let isPrimary: Bool
    let onDelete: () -> Void
    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 4) {
                Text(formatServerUrl(server))
                    .font(.body)
                    .foregroundColor(.white)
                if isPrimary {
                    Label("Primary upload server", systemImage: "star.fill")
                        .font(.caption)
                        .foregroundColor(.yellow)
                }
            }
            Spacer()
            Button(action: onDelete) {
                Image(systemName: "trash")
                    .foregroundColor(.red)
            }
        }
        .padding(.vertical, 8)
    }
    private func formatServerUrl(_ url: String) -> String {
        var formatted = url
        if formatted.hasPrefix("https://") {
            formatted = String(formatted.dropFirst(8))
        } else if formatted.hasPrefix("http://") {
            formatted = String(formatted.dropFirst(7))
        }
        if formatted.hasSuffix("/") {
            formatted = String(formatted.dropLast())
        }
        return formatted
    }
}
// MARK: - Add Server Sheet
struct AddServerSheet: View {
    @Binding var serverUrl: String
    let suggestedServers: [BlossomServerInfo]
    let existingServers: [String]
    let onAdd: (String) -> Void
    let onCancel: () -> Void
    @FocusState private var isTextFieldFocused: Bool
    @State private var showingSuggestions = true
    var availableSuggestions: [BlossomServerInfo] {
        suggestedServers.filter { !existingServers.contains($0.url) }
    }
    var body: some View {
        NavigationView {
            ZStack {
                Color.black.ignoresSafeArea()
                ScrollView {
                    VStack(spacing: 20) {
                        Text("Add Blossom Server")
                            .font(.headline)
                            .foregroundColor(.white)
                            .padding(.top)
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Server URL")
                                .font(.caption)
                                .foregroundColor(.gray)
                            TextField("blossom.example.com", text: $serverUrl)
                                .textFieldStyle(RoundedBorderTextFieldStyle())
                                .autocapitalization(.none)
                                .disableAutocorrection(true)
                                .keyboardType(.URL)
                                .focused($isTextFieldFocused)
                        }
                        .padding(.horizontal)
                        if !availableSuggestions.isEmpty && showingSuggestions {
                            VStack(alignment: .leading, spacing: 12) {
                                HStack {
                                    Text("Suggested Servers")
                                        .font(.headline)
                                        .foregroundColor(.white)
                                    Spacer()
                                    Button("Hide") {
                                        withAnimation {
                                            showingSuggestions = false
                                        }
                                    }
                                    .font(.caption)
                                    .foregroundColor(.blue)
                                }
                                .padding(.horizontal)
                                ForEach(availableSuggestions) { server in
                                    SuggestedServerRow(
                                        server: server,
                                        onSelect: {
                                            serverUrl = server.url
                                            isTextFieldFocused = false
                                        }
                                    )
                                    .padding(.horizontal)
                                }
                            }
                            .padding(.top)
                        }
                        Spacer(minLength: 40)
                    }
                }
                VStack {
                    Spacer()
                    HStack(spacing: 16) {
                        Button("Cancel") {
                            onCancel()
                        }
                        .foregroundColor(.red)
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.gray.opacity(0.2))
                        .cornerRadius(10)
                        Button("Add") {
                            onAdd(serverUrl)
                        }
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.blue)
                        .cornerRadius(10)
                        .disabled(serverUrl.isEmpty)
                    }
                    .padding()
                    .background(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                Color.black,
                                Color.black.opacity(0.95),
                                Color.black.opacity(0.9)
                            ]),
                            startPoint: .bottom,
                            endPoint: .top
                        )
                        .ignoresSafeArea()
                    )
                }
            }
            .preferredColorScheme(.dark)
            .onAppear {
                isTextFieldFocused = true
            }
        }
    }
}
// MARK: - Suggested Server Row
struct SuggestedServerRow: View {
    let server: BlossomServerInfo
    let onSelect: () -> Void
    var body: some View {
        Button(action: onSelect) {
            VStack(alignment: .leading, spacing: 6) {
                HStack {
                    VStack(alignment: .leading, spacing: 2) {
                        Text(server.name)
                            .font(.body)
                            .foregroundColor(.white)
                            .lineLimit(1)
                        Text(formatServerUrl(server.url))
                            .font(.caption)
                            .foregroundColor(.gray)
                            .lineLimit(1)
                    }
                    Spacer()
                    if let subtitle = server.subtitle {
                        Text(subtitle)
                            .font(.caption)
                            .foregroundColor(subtitleColor(for: server))
                            .padding(.horizontal, 8)
                            .padding(.vertical, 4)
                            .background(subtitleColor(for: server).opacity(0.2))
                            .cornerRadius(4)
                    }
                }
                if !server.description.isEmpty {
                    Text(server.description)
                        .font(.caption)
                        .foregroundColor(.gray)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)
                }
                if let accessMessage = server.accessMessage {
                    Text(accessMessage)
                        .font(.caption2)
                        .foregroundColor(.orange)
                        .lineLimit(1)
                }
            }
            .padding(12)
            .background(Color.gray.opacity(0.15))
            .cornerRadius(8)
        }
        .buttonStyle(PlainButtonStyle())
    }
    private func formatServerUrl(_ url: String) -> String {
        var formatted = url
        if formatted.hasPrefix("https://") {
            formatted = String(formatted.dropFirst(8))
        } else if formatted.hasPrefix("http://") {
            formatted = String(formatted.dropFirst(7))
        }
        if formatted.hasSuffix("/") {
            formatted = String(formatted.dropLast())
        }
        return formatted
    }
    private func subtitleColor(for server: BlossomServerInfo) -> Color {
        if server.isPaid || server.isWhitelisted {
            return .orange
        } else {
            return .green
        }
    }
}
</file>

<file path="Sources/Ambulando/Views/HomeFeedView.swift">
import SwiftUI
import NDKSwift
import NDKSwiftUI
import AVFoundation
struct HomeFeedView: View {
    @EnvironmentObject var nostrManager: NostrManager
    @EnvironmentObject var appState: AppState
    @EnvironmentObject var blossomServerManager: BlossomServerManager
    @State private var audioEvents: [AudioEvent] = []
    @State private var showRecordingHint = true
    @State private var recordingScale: CGFloat = 1
    @State private var recordingOpacity: Double = 1
    @State private var dragOffset = CGSize.zero
    @State private var isDragging = false
    @State private var dataSourceTask: Task<Void, Never>?
    @State private var selectedRelay: String? = nil
    @State private var showRelaySelector = false
    // Recording states
    @State private var audioRecorder: AVAudioRecorder?
    @State private var recordingTimer: Timer?
    @State private var recordingDuration: TimeInterval = 0
    @State private var showingRecordingUI = false
    @State private var recordingWaveform: [CGFloat] = []
    @State private var fullWaveform: [Double] = [] // Store full waveform for imeta
    // Upload and preview states
    @State private var isUploading = false
    @State private var uploadedURL: String?
    @State private var isShowingPreview = false
    @State private var audioPlayer: AVAudioPlayer?
    // Playback states
    @State private var isPlaying = false
    @State private var playbackTimer: Timer?
    @State private var playbackProgress: TimeInterval = 0
    @State private var playbackWaveformProgress: Int = 0
    var sortedEvents: [AudioEvent] {
        audioEvents.sorted { $0.sortScore > $1.sortScore }
    }
    var body: some View {
        ZStack {
            VStack(spacing: 0) {
                // Header
                HeaderView(selectedRelay: $selectedRelay, showRelaySelector: $showRelaySelector)
                    .padding(.horizontal, 16)
                    .padding(.vertical, 8)
                // Feed - Always show UI immediately, no loading states
                if audioEvents.isEmpty {
                    EmptyFeedView()
                } else {
                    ScrollView {
                        LazyVStack(spacing: 0) {
                            ForEach(sortedEvents) { audioEvent in
                                AudioEventCard(audioEvent: audioEvent)
                                    .transition(.asymmetric(
                                        insertion: .opacity,
                                        removal: .scale(scale: 0.8).combined(with: .opacity)
                                    ))
                                Divider()
                                    .background(Color.white.opacity(0.1))
                            }
                        }
                    }
                    .refreshable {
                        await refreshAudioEvents()
                    }
                }
            }
            // Recording UI overlay
            if showingRecordingUI {
                RecordingOverlay(
                    duration: recordingDuration,
                    waveform: recordingWaveform,
                    onCancel: cancelRecording,
                    onComplete: completeRecording,
                    isUploading: isUploading,
                    uploadedURL: uploadedURL,
                    onPreview: playPreview,
                    onPublish: publishRecording,
                    isPlaying: isPlaying,
                    playbackProgress: playbackProgress,
                    playbackWaveformProgress: playbackWaveformProgress,
                    replyingTo: appState.replyingTo
                )
                .transition(.opacity.combined(with: .scale))
            }
            // Floating record button - hide when recording overlay is shown
            if !showingRecordingUI {
                VStack {
                    Spacer()
                    HStack {
                        Spacer()
                        RecordButton(
                            isRecording: $appState.isRecording,
                            onStartRecording: startRecording,
                            onStopRecording: stopRecording
                        )
                        .padding(.horizontal, 20)
                        .padding(.bottom, 20)
                    }
                }
            }
            // Relay selector modal
            if showRelaySelector {
                Color.black.opacity(0.4)
                    .ignoresSafeArea()
                    .onTapGesture {
                        showRelaySelector = false
                    }
                    .zIndex(1)
                RelaySelectorView(
                    selectedRelay: $selectedRelay,
                    isPresented: $showRelaySelector
                )
                .transition(.opacity.combined(with: .scale(scale: 0.95)))
                .zIndex(2)
            }
        }
        .animation(.easeInOut(duration: 0.2), value: showRelaySelector)
        .onAppear {
            startStreamingAudioEvents()
        }
        .onChange(of: selectedRelay) { _, _ in
            // Restart streaming with new relay filter
            startStreamingAudioEvents()
        }
        .onChange(of: appState.replyingTo) { _, newValue in
            // Start recording when reply context is set
            if newValue != nil {
                startRecording()
            }
        }
        .onDisappear {
            dataSourceTask?.cancel()
        }
    }
    private func startStreamingAudioEvents() {
        guard let ndk = nostrManager.ndk else { return }
        // Cancel any existing task
        dataSourceTask?.cancel()
        // Clear events when switching relays
        audioEvents.removeAll()
        // Create filter for audio events
        let filter = NDKFilter(
            kinds: [1222, 1244]
        )
        // If a specific relay is selected, use it; otherwise use all relays
        let relayUrls: Set<String>? = selectedRelay != nil ? [selectedRelay!] : nil
        // Start streaming task
        dataSourceTask = Task {
            // Stream audio events
            // When a specific relay is selected, use networkOnly to ensure we only get events from that relay
            // (cached events don't store relay information, so exclusiveRelays can't filter them)
            let dataSource: NDKDataSource<NDKEvent>
            if let relayUrls = relayUrls {
                // Use networkOnly to ensure we only get events from the selected relay
                dataSource = ndk.observe(filter: filter, maxAge: 0, cachePolicy: .networkOnly, relays: relayUrls, exclusiveRelays: true)
            } else {
                // For all relays, use cache for better performance
                dataSource = ndk.observe(filter: filter, maxAge: 0, cachePolicy: .cacheWithNetwork)
            }
            for await event in dataSource.events {
                // Check if task was cancelled
                if Task.isCancelled { break }
                // Skip muted users if session data is available
                if let sessionData = ndk.sessionData, sessionData.isMuted(event.pubkey) {
                    continue
                }
                // Get WOT score from session data
                let wotScore: Double
                if let sessionData = ndk.sessionData {
                    let score = sessionData.webOfTrust[event.pubkey] ?? 0
                    // Normalize score (direct follows have Int.max)
                    wotScore = score == Int.max ? 1.0 : min(Double(score) / 10.0, 1.0)
                } else {
                    wotScore = 0.1
                }
                if let audioEvent = AudioEvent.from(event: event, webOfTrustScore: wotScore) {
                    await MainActor.run {
                        // Add new event if it doesn't already exist
                        if !self.audioEvents.contains(where: { $0.id == audioEvent.id }) {
                            withAnimation(.easeOut(duration: 0.3)) {
                                self.audioEvents.append(audioEvent)
                            }
                        }
                    }
                }
            }
        }
    }
    private func refreshAudioEvents() async {
        guard nostrManager.ndk != nil else { return }
        // Clear existing events for a fresh feed
        await MainActor.run {
            audioEvents.removeAll()
        }
        // Re-start the streaming with fresh data
        // This will fetch from network due to maxAge: 0 in the main stream
        startStreamingAudioEvents()
    }
    private func startRecording() {
        // Request microphone permission
        Task {
            let granted = await AVAudioApplication.requestRecordPermission()
            if granted {
                await MainActor.run {
                    setupRecording()
                }
            }
        }
    }
    private func setupRecording() {
        let audioSession = AVAudioSession.sharedInstance()
        do {
            try audioSession.setCategory(.playAndRecord, mode: .default, options: [.allowBluetooth, .defaultToSpeaker])
            try audioSession.setActive(true)
            let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
            let audioFilename = documentsPath.appendingPathComponent("voice_\(Date().timeIntervalSince1970).m4a")
            let settings = [
                AVFormatIDKey: Int(kAudioFormatMPEG4AAC),
                AVSampleRateKey: 44100,
                AVNumberOfChannelsKey: 1,
                AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue
            ]
            audioRecorder = try AVAudioRecorder(url: audioFilename, settings: settings)
            audioRecorder?.isMeteringEnabled = true
            audioRecorder?.record()
            appState.isRecording = true
            appState.recordingStartTime = Date()
            showingRecordingUI = true
            recordingDuration = 0
            fullWaveform = [] // Reset waveform data
            // Start timer for duration and waveform
            recordingTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { _ in
                updateRecording()
            }
        } catch {
            print("Failed to start recording: \(error)")
        }
    }
    private func updateRecording() {
        guard let recorder = audioRecorder,
              let startTime = appState.recordingStartTime else { return }
        recorder.updateMeters()
        recordingDuration = Date().timeIntervalSince(startTime)
        // Update waveform using peak power for more responsive visualization
        // Peak power gives instantaneous levels, average power is too smoothed
        let peakPower = recorder.peakPower(forChannel: 0)
        // Convert from decibels to linear scale (0-1 range)
        // Peak power range is typically -160 (silence) to 0 (max)
        // Clamp to reasonable range for better visualization
        let clampedPower = max(-50, peakPower) // Clamp to -50 dB minimum
        let normalizedValue = pow(10, clampedPower / 20)
        recordingWaveform.append(CGFloat(normalizedValue))
        // Store normalized amplitude value for imeta (0-1 range)
        fullWaveform.append(Double(normalizedValue))
        // Keep last 50 samples for UI display
        if recordingWaveform.count > 50 {
            recordingWaveform.removeFirst()
        }
        // Auto-stop at 60 seconds
        if recordingDuration >= 60 {
            stopRecording()
        }
    }
    private func stopRecording() {
        recordingTimer?.invalidate()
        recordingTimer = nil
        audioRecorder?.stop()
        appState.isRecording = false
        // Show completion UI
        withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {
            // Transition to publish state
        }
    }
    private func cancelRecording() {
        recordingTimer?.invalidate()
        recordingTimer = nil
        audioRecorder?.stop()
        audioRecorder?.deleteRecording()
        audioRecorder = nil
        audioPlayer?.stop()
        audioPlayer = nil
        // Clean up playback state
        stopPlaybackTracking()
        appState.isRecording = false
        appState.replyingTo = nil  // Clear reply context
        showingRecordingUI = false
        recordingWaveform = []
        fullWaveform = []
        isUploading = false
        self.uploadedURL = nil
        isShowingPreview = false
    }
    private func completeRecording() {
        guard let recorder = audioRecorder,
              let ndk = nostrManager.ndk,
              let signer = ndk.signer else { return }
        // Stop the timer and recording first
        recordingTimer?.invalidate()
        recordingTimer = nil
        recorder.stop()
        appState.isRecording = false
        let audioUrl = recorder.url
        // Start upload process
        isUploading = true
        Task {
            do {
                // Read audio file data
                let audioData = try Data(contentsOf: audioUrl)
                // Check if we have actual audio data
                guard audioData.count > 1000 else { // At least 1KB of data
                    throw NSError(domain: "RecordingError", code: 1, userInfo: [NSLocalizedDescriptionKey: "Recording file is too small or empty"])
                }
                // Upload to Blossom servers with fallback
                var uploadResult: String? = nil
                var uploadError: Error? = nil
                for server in blossomServerManager.allServers {
                    do {
                        // Create blossom client and upload
                        let blossomClient = BlossomClient()
                        // Upload audio file with auth
                        let result = try await blossomClient.uploadWithAuth(
                            data: audioData,
                            mimeType: "audio/m4a",
                            to: server,
                            signer: signer,
                            ndk: ndk
                        )
                        uploadResult = result.url
                        print("Successfully uploaded audio to \(server)")
                        break // Success, no need to try other servers
                    } catch {
                        print("Failed to upload to \(server): \(error)")
                        uploadError = error
                        continue // Try next server
                    }
                }
                guard let finalUploadedURL = uploadResult else {
                    throw uploadError ?? BlossomError.uploadFailed
                }
                await MainActor.run {
                    self.uploadedURL = finalUploadedURL
                    self.isUploading = false
                    self.isShowingPreview = true
                }
            } catch {
                print("Failed to upload audio: \(error)")
                await MainActor.run {
                    self.isUploading = false
                    // TODO: Show error to user
                }
            }
        }
    }
    private func compressWaveform(_ waveform: [Double], targetSamples: Int) -> [Double] {
        guard waveform.count > targetSamples else { return waveform }
        var compressed: [Double] = []
        let bucketSize = Double(waveform.count) / Double(targetSamples)
        for i in 0..<targetSamples {
            let startIndex = Int(Double(i) * bucketSize)
            let endIndex = min(Int(Double(i + 1) * bucketSize), waveform.count)
            if startIndex < endIndex {
                // Take the average of values in this bucket
                let bucketValues = waveform[startIndex..<endIndex]
                let average = bucketValues.reduce(0.0, +) / Double(bucketValues.count)
                compressed.append(average)
            }
        }
        return compressed
    }
    private func playPreview() {
        guard let uploadedURL = uploadedURL,
              let url = URL(string: uploadedURL) else { return }
        Task {
            do {
                // Download and play the audio
                let (data, _) = try await URLSession.shared.data(from: url)
                await MainActor.run {
                    do {
                        // Configure audio session for playback with Bluetooth support
                        let audioSession = AVAudioSession.sharedInstance()
                        try audioSession.setCategory(.playback, mode: .default, options: [.allowBluetooth, .allowAirPlay])
                        try audioSession.setActive(true)
                        self.audioPlayer = try AVAudioPlayer(data: data)
                        self.audioPlayer?.volume = 1.0
                        self.audioPlayer?.play()
                        // Start playback tracking
                        self.isPlaying = true
                        self.playbackProgress = 0
                        self.playbackWaveformProgress = 0
                        // Start timer to track playback progress
                        self.playbackTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { _ in
                            self.updatePlaybackProgress()
                        }
                    } catch {
                        // Failed to play audio preview
                    }
                }
            } catch {
                // Failed to download audio for preview
            }
        }
    }
    private func updatePlaybackProgress() {
        guard let player = audioPlayer, player.isPlaying else {
            // Playback finished or stopped
            stopPlaybackTracking()
            return
        }
        playbackProgress = player.currentTime
        // Update waveform progress based on playback time and total duration
        if player.duration > 0 {
            let progressRatio = player.currentTime / player.duration
            playbackWaveformProgress = Int(progressRatio * Double(recordingWaveform.count))
        }
    }
    private func stopPlaybackTracking() {
        playbackTimer?.invalidate()
        playbackTimer = nil
        isPlaying = false
        playbackProgress = 0
        playbackWaveformProgress = 0
    }
    private func publishRecording() {
        guard let recorder = audioRecorder,
              let uploadedURL = uploadedURL,
              let ndk = nostrManager.ndk else { return }
        let finalDuration = recordingDuration
        // Compress waveform to less than 100 values as recommended
        let compressedWaveform = compressWaveform(fullWaveform, targetSamples: 50)
        Task {
            do {
                // Create imeta tag with waveform and duration
                var imetaComponents = ["imeta"]
                imetaComponents.append("url \(uploadedURL)")
                imetaComponents.append("m audio/m4a")
                imetaComponents.append("duration \(Int(finalDuration))")
                // Add waveform data as space-separated values
                let waveformString = compressedWaveform
                    .map { String(format: "%.2f", $0) }
                    .joined(separator: " ")
                imetaComponents.append("waveform \(waveformString)")
                // Publish audio event
                _ = try await ndk.publish { builder in
                    let eventBuilder = builder
                        .kind(appState.replyingTo != nil ? 1244 : 1222) // Use 1244 for replies
                        .content(uploadedURL)
                        .tag(imetaComponents)
                    // Add reply tags if replying
                    if let replyingTo = appState.replyingTo {
                        eventBuilder
                            .tag(["e", replyingTo.id, "", "reply"]) // Reply to original event
                            .tag(["p", replyingTo.author.pubkey]) // Mention original author
                    }
                    return eventBuilder
                }
                await MainActor.run {
                    showingRecordingUI = false
                    recordingWaveform = []
                    fullWaveform = []
                    audioRecorder = nil
                    self.uploadedURL = nil
                    self.isShowingPreview = false
                    audioPlayer?.stop()
                    audioPlayer = nil
                    appState.replyingTo = nil  // Clear reply context after publishing
                    // Clean up playback state
                    self.stopPlaybackTracking()
                }
                // Clean up local file
                try? FileManager.default.removeItem(at: recorder.url)
            } catch {
                print("Failed to publish audio event: \(error)")
                await MainActor.run {
                    showingRecordingUI = false
                    // TODO: Show error to user
                }
            }
        }
    }
}
// MARK: - Header View
struct HeaderView: View {
    @EnvironmentObject var appState: AppState
    @EnvironmentObject var nostrManager: NostrManager
    @Binding var selectedRelay: String?
    @Binding var showRelaySelector: Bool
    @State private var selectedRelayInfo: NDKRelayInformation?
    var body: some View {
        HStack {
            HStack(spacing: 8) {
                // Relay icon if available
                if let icon = selectedRelayInfo?.icon,
                   let iconURL = URL(string: icon) {
                    AsyncImage(url: iconURL) { image in
                        image
                            .resizable()
                            .scaledToFill()
                    } placeholder: {
                        ProgressView()
                            .scaleEffect(0.5)
                    }
                    .frame(width: 24, height: 24)
                    .clipShape(Circle())
                }
                // Title - Shows relay name or AMBULANDO
                Text(displayTitle)
                    .font(.system(size: 24, weight: .black))
                    .foregroundStyle(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                Color.white,
                                Color.white.opacity(0.8)
                            ]),
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )
                Image(systemName: "chevron.down")
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(Color.white.opacity(0.8))
            }
            .contentShape(Rectangle()) // Make entire area tappable
            .onTapGesture {
                showRelaySelector = true
            }
            Spacer()
            // Settings button
            NavigationLink(destination: SettingsView()) {
                Image(systemName: "gearshape.fill")
                    .font(.system(size: 20))
                    .foregroundColor(Color.white.opacity(0.8))
                    .frame(width: 36, height: 36)
                    .background(
                        Circle()
                            .fill(Color.white.opacity(0.1))
                    )
            }
        }
        .task {
            await loadRelayInfo()
        }
        .onChange(of: selectedRelay) { _, _ in
            Task {
                await loadRelayInfo()
            }
        }
    }
    private var displayTitle: String {
        if selectedRelay == nil {
            return "AMBULANDO"
        } else if let name = selectedRelayInfo?.name, !name.isEmpty {
            return name.uppercased()
        } else if let relay = selectedRelay {
            return formatRelayForDisplay(relay).uppercased()
        } else {
            return "AMBULANDO"
        }
    }
    private func loadRelayInfo() async {
        guard let selectedRelay = selectedRelay,
              let ndk = nostrManager.ndk else {
            selectedRelayInfo = nil
            return
        }
        // Find the relay in the pool
        let relays = await ndk.relays
        for relay in relays {
            if relay.url == selectedRelay {
                selectedRelayInfo = await relay.info
                break
            }
        }
    }
    private func formatRelayForDisplay(_ url: String) -> String {
        var formatted = url
        if formatted.hasPrefix("wss://") {
            formatted = String(formatted.dropFirst(6))
        } else if formatted.hasPrefix("ws://") {
            formatted = String(formatted.dropFirst(5))
        }
        if formatted.hasSuffix("/") {
            formatted = String(formatted.dropLast())
        }
        // Truncate long URLs
        if formatted.count > 20 {
            return String(formatted.prefix(17)) + "..."
        }
        return formatted
    }
}
// MARK: - Empty Feed View
struct EmptyFeedView: View {
    var body: some View {
        VStack(spacing: 24) {
            Spacer()
            Image(systemName: "waveform.circle")
                .font(.system(size: 80))
                .foregroundStyle(
                    LinearGradient(
                        gradient: Gradient(colors: [
                            Color.purple.opacity(0.6),
                            Color.blue.opacity(0.4)
                        ]),
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
            VStack(spacing: 12) {
                Text("No voices yet")
                    .font(.system(size: 24, weight: .semibold))
                    .foregroundColor(.white)
                Text("Be the first to share your journey")
                    .font(.system(size: 16))
                    .foregroundColor(Color.white.opacity(0.6))
            }
            Spacer()
        }
    }
}
// MARK: - Record Button
struct RecordButton: View {
    @Binding var isRecording: Bool
    let onStartRecording: () -> Void
    let onStopRecording: () -> Void
    @State private var pulseScale: CGFloat = 1
    @State private var pulseOpacity: Double = 0.5
    var body: some View {
        ZStack {
            // Pulse effect when recording
            if isRecording {
                Circle()
                    .fill(Color.red.opacity(0.3))
                    .frame(width: 92, height: 92)
                    .scaleEffect(pulseScale)
                    .opacity(pulseOpacity)
                    .animation(
                        .easeInOut(duration: 1)
                        .repeatForever(autoreverses: true),
                        value: pulseScale
                    )
            }
            // Main button
            Button(action: {
                if isRecording {
                    onStopRecording()
                } else {
                    onStartRecording()
                }
            }) {
                ZStack {
                    Circle()
                        .fill(
                            LinearGradient(
                                gradient: Gradient(colors: [
                                    isRecording ? Color.red : Color.purple,
                                    isRecording ? Color.red.opacity(0.8) : Color(red: 0.5, green: 0.1, blue: 0.9)
                                ]),
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 64, height: 64)
                        .shadow(color: isRecording ? Color.red.opacity(0.5) : Color.purple.opacity(0.5), 
                               radius: 15, x: 0, y: 5)
                    Image(systemName: isRecording ? "stop.fill" : "mic.fill")
                        .font(.system(size: 28))
                        .foregroundColor(.white)
                }
            }
            .scaleEffect(isRecording ? 1.1 : 1)
            .animation(.spring(response: 0.3, dampingFraction: 0.6), value: isRecording)
        }
        .onAppear {
            if isRecording {
                withAnimation(.easeInOut(duration: 1).repeatForever(autoreverses: true)) {
                    pulseScale = 1.3
                    pulseOpacity = 0
                }
            }
        }
        .onChange(of: isRecording) { _, newValue in
            if newValue {
                withAnimation(.easeInOut(duration: 1).repeatForever(autoreverses: true)) {
                    pulseScale = 1.3
                    pulseOpacity = 0
                }
            } else {
                pulseScale = 1
                pulseOpacity = 0.5
            }
        }
    }
}
// MARK: - Recording Overlay
struct RecordingOverlay: View {
    let duration: TimeInterval
    let waveform: [CGFloat]
    let onCancel: () -> Void
    let onComplete: () -> Void
    let isUploading: Bool
    let uploadedURL: String?
    let onPreview: () -> Void
    let onPublish: () -> Void
    let isPlaying: Bool
    let playbackProgress: TimeInterval
    let playbackWaveformProgress: Int
    let replyingTo: AudioEvent?
    @State private var rotationAngle: Double = 0
    var formattedDuration: String {
        let minutes = Int(duration) / 60
        let seconds = Int(duration) % 60
        return String(format: "%d:%02d", minutes, seconds)
    }
    var isRecordingComplete: Bool {
        !isUploading && uploadedURL == nil
    }
    var isPreviewReady: Bool {
        !isUploading && uploadedURL != nil
    }
    var formattedPlaybackProgress: String {
        let minutes = Int(playbackProgress) / 60
        let seconds = Int(playbackProgress) % 60
        return String(format: "%d:%02d", minutes, seconds)
    }
    var body: some View {
        ZStack {
            // Background blur
            Color.black.opacity(0.8)
                .ignoresSafeArea()
            VStack {
                // Reply context at the top
                if let replyingTo = replyingTo {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Replying to")
                            .font(.system(size: 14))
                            .foregroundColor(Color.white.opacity(0.6))
                        HStack {
                            NDKProfilePicture(pubkey: replyingTo.author.pubkey, size: 32)
                            VStack(alignment: .leading) {
                                Text(String(replyingTo.author.pubkey.prefix(8)))
                                    .font(.system(size: 14, weight: .semibold))
                                    .foregroundColor(.white)
                                Text("Voice message")
                                    .font(.system(size: 12))
                                    .foregroundColor(Color.white.opacity(0.5))
                            }
                            Spacer()
                        }
                        .padding()
                        .background(
                            RoundedRectangle(cornerRadius: 12)
                                .fill(Color.white.opacity(0.05))
                        )
                    }
                    .padding(.horizontal)
                    .padding(.top, 20)
                }
                Spacer()
                // Waveform visualization
                HStack(spacing: 2) {
                    ForEach(0..<waveform.count, id: \.self) { index in
                        Capsule()
                            .fill(
                                LinearGradient(
                                    gradient: Gradient(colors: [
                                        // Show different colors for played vs unplayed parts
                                        index < playbackWaveformProgress ? Color.green : Color.purple,
                                        index < playbackWaveformProgress ? Color.mint : Color.blue
                                    ]),
                                    startPoint: .top,
                                    endPoint: .bottom
                                )
                            )
                            .frame(width: 4, height: 20 + waveform[index] * 80)
                            .animation(.easeOut(duration: 0.1), value: waveform[index])
                            .animation(.easeInOut(duration: 0.2), value: playbackWaveformProgress)
                    }
                }
                .frame(height: 100)
                // Duration - show playback progress when playing, recording duration otherwise
                Text(isPlaying ? formattedPlaybackProgress : formattedDuration)
                    .font(.system(size: 48, weight: .bold, design: .monospaced))
                    .foregroundColor(.white)
                    .padding(.vertical, 30)
                Spacer()
            }
            // Bottom controls
            VStack {
                Spacer()
                HStack {
                    // Cancel button (bottom left)
                    Button(action: onCancel) {
                        ZStack {
                            Circle()
                                .fill(Color.white.opacity(0.15))
                                .frame(width: 56, height: 56)
                            Image(systemName: "xmark")
                                .font(.system(size: 24))
                                .foregroundColor(.white)
                        }
                    }
                    .padding(.leading, 20)
                    Spacer()
                    HStack(spacing: 16) {
                        // Preview button (when upload is complete)
                        if isPreviewReady {
                            Button(action: onPreview) {
                                ZStack {
                                    Circle()
                                        .fill(Color.white.opacity(0.15))
                                        .frame(width: 56, height: 56)
                                    Image(systemName: "play.fill")
                                        .font(.system(size: 24))
                                        .foregroundColor(.white)
                                }
                            }
                        }
                        // Main action button (right side)
                        Button(action: {
                            if isRecordingComplete {
                                onComplete()
                            } else if isPreviewReady {
                                onPublish()
                            }
                        }) {
                            ZStack {
                                Circle()
                                    .fill(
                                        LinearGradient(
                                            gradient: Gradient(colors: [
                                                Color.purple,
                                                Color(red: 0.5, green: 0.1, blue: 0.9)
                                            ]),
                                            startPoint: .topLeading,
                                            endPoint: .bottomTrailing
                                        )
                                    )
                                    .frame(width: 56, height: 56)
                                    .shadow(color: Color.purple.opacity(0.5), radius: 15, x: 0, y: 5)
                                if isUploading {
                                    // Upload animation
                                    Circle()
                                        .stroke(Color.white.opacity(0.3), lineWidth: 2)
                                        .frame(width: 40, height: 40)
                                    Circle()
                                        .trim(from: 0, to: 0.3)
                                        .stroke(Color.white, lineWidth: 2)
                                        .frame(width: 40, height: 40)
                                        .rotationEffect(Angle(degrees: rotationAngle))
                                        .animation(.linear(duration: 1).repeatForever(autoreverses: false), value: rotationAngle)
                                } else {
                                    Image(systemName: isPreviewReady ? "paperplane.fill" : "checkmark")
                                        .font(.system(size: 24))
                                        .foregroundColor(.white)
                                }
                            }
                        }
                        .disabled(isUploading)
                    }
                    .padding(.trailing, 20)
                }
                .padding(.bottom, 20)
            }
        }
        .onAppear {
            if isUploading {
                rotationAngle = 360
            }
        }
        .onChange(of: isUploading) { _, newValue in
            if newValue {
                rotationAngle = 360
            } else {
                rotationAngle = 0
            }
        }
    }
}
</file>

<file path="Sources/Ambulando/Views/QRScannerView.swift">
import SwiftUI
import AVFoundation
struct QRScannerView: UIViewControllerRepresentable {
    var onScan: (String) -> Void
    var onDismiss: () -> Void
    func makeUIViewController(context: Context) -> QRScannerViewController {
        let controller = QRScannerViewController()
        controller.onScan = onScan
        controller.onDismiss = onDismiss
        return controller
    }
    func updateUIViewController(_ uiViewController: QRScannerViewController, context: Context) {}
}
class QRScannerViewController: UIViewController, AVCaptureMetadataOutputObjectsDelegate {
    var captureSession: AVCaptureSession?
    var previewLayer: AVCaptureVideoPreviewLayer?
    var onScan: ((String) -> Void)?
    var onDismiss: (() -> Void)?
    override func viewDidLoad() {
        super.viewDidLoad()
        view.backgroundColor = UIColor.black
        captureSession = AVCaptureSession()
        guard let videoCaptureDevice = AVCaptureDevice.default(for: .video) else { return }
        let videoInput: AVCaptureDeviceInput
        do {
            videoInput = try AVCaptureDeviceInput(device: videoCaptureDevice)
        } catch {
            return
        }
        if (captureSession?.canAddInput(videoInput) ?? false) {
            captureSession?.addInput(videoInput)
        } else {
            failed()
            return
        }
        let metadataOutput = AVCaptureMetadataOutput()
        if (captureSession?.canAddOutput(metadataOutput) ?? false) {
            captureSession?.addOutput(metadataOutput)
            metadataOutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)
            metadataOutput.metadataObjectTypes = [.qr]
        } else {
            failed()
            return
        }
        previewLayer = AVCaptureVideoPreviewLayer(session: captureSession!)
        previewLayer!.frame = view.layer.bounds
        previewLayer!.videoGravity = .resizeAspectFill
        view.layer.addSublayer(previewLayer!)
        // Add close button
        let closeButton = UIButton(type: .custom)
        closeButton.setImage(UIImage(systemName: "xmark.circle.fill"), for: .normal)
        closeButton.tintColor = .white
        closeButton.contentMode = .scaleAspectFit
        closeButton.translatesAutoresizingMaskIntoConstraints = false
        closeButton.addTarget(self, action: #selector(closeTapped), for: .touchUpInside)
        let config = UIImage.SymbolConfiguration(pointSize: 30, weight: .medium)
        closeButton.setImage(UIImage(systemName: "xmark.circle.fill", withConfiguration: config), for: .normal)
        view.addSubview(closeButton)
        NSLayoutConstraint.activate([
            closeButton.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 20),
            closeButton.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20),
            closeButton.widthAnchor.constraint(equalToConstant: 44),
            closeButton.heightAnchor.constraint(equalToConstant: 44)
        ])
        // Add scanning frame
        let scanningFrame = UIView()
        scanningFrame.backgroundColor = .clear
        scanningFrame.layer.borderColor = UIColor.systemPurple.cgColor
        scanningFrame.layer.borderWidth = 3
        scanningFrame.layer.cornerRadius = 12
        scanningFrame.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(scanningFrame)
        NSLayoutConstraint.activate([
            scanningFrame.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            scanningFrame.centerYAnchor.constraint(equalTo: view.centerYAnchor),
            scanningFrame.widthAnchor.constraint(equalToConstant: 250),
            scanningFrame.heightAnchor.constraint(equalToConstant: 250)
        ])
        // Add instruction label
        let instructionLabel = UILabel()
        instructionLabel.text = "Scan QR code"
        instructionLabel.textColor = .white
        instructionLabel.font = UIFont.systemFont(ofSize: 18, weight: .medium)
        instructionLabel.textAlignment = .center
        instructionLabel.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(instructionLabel)
        NSLayoutConstraint.activate([
            instructionLabel.topAnchor.constraint(equalTo: scanningFrame.bottomAnchor, constant: 30),
            instructionLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor)
        ])
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            self?.captureSession?.startRunning()
        }
    }
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        if (captureSession?.isRunning == true) {
            captureSession?.stopRunning()
        }
    }
    @objc func closeTapped() {
        onDismiss?()
    }
    func failed() {
        let ac = UIAlertController(title: "Scanning not supported", message: "Your device does not support scanning a code from an item. Please use a device with a camera.", preferredStyle: .alert)
        ac.addAction(UIAlertAction(title: "OK", style: .default))
        present(ac, animated: true)
        captureSession = nil
        onDismiss?()
    }
    func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection) {
        captureSession?.stopRunning()
        if let metadataObject = metadataObjects.first {
            guard let readableObject = metadataObject as? AVMetadataMachineReadableCodeObject else { return }
            guard let stringValue = readableObject.stringValue else { return }
            AudioServicesPlaySystemSound(SystemSoundID(kSystemSoundID_Vibrate))
            onScan?(stringValue)
        }
    }
}
</file>

<file path="Sources/Ambulando/Views/RelayManagementView.swift">
import SwiftUI
import NDKSwift
struct RelayManagementView: View {
    @EnvironmentObject var nostrManager: NostrManager
    @State private var showAddRelay = false
    var body: some View {
        List {
            if let ndk = nostrManager.ndk {
                RelayListContent(ndk: ndk, nostrManager: nostrManager)
            } else {
                VStack(spacing: 16) {
                    Image(systemName: "network.slash")
                        .font(.system(size: 60))
                        .foregroundStyle(Color.white.opacity(0.3))
                    Text("NDK not initialized")
                        .font(.headline)
                        .foregroundStyle(Color.white.opacity(0.6))
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 40)
                .listRowBackground(Color.clear)
            }
            Section {
                Button(action: { showAddRelay = true }) {
                    Label {
                        Text("Add Relay")
                            .foregroundColor(.purple)
                    } icon: {
                        Image(systemName: "plus.circle")
                            .foregroundColor(.purple)
                    }
                }
                .listRowBackground(Color.white.opacity(0.05))
            }
        }
        .navigationTitle("Relay Management")
        .navigationBarTitleDisplayMode(.inline)
        .scrollContentBackground(.hidden)
        .background(
            LinearGradient(
                gradient: Gradient(colors: [
                    Color(red: 0.05, green: 0.02, blue: 0.08),
                    Color(red: 0.02, green: 0.01, blue: 0.03),
                    Color.black
                ]),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .ignoresSafeArea()
        )
        .sheet(isPresented: $showAddRelay) {
            AddRelayView()
        }
    }
}
// Separate view for relay list content that observes NDK relays
struct RelayListContent: View {
    let ndk: NDK
    let nostrManager: NostrManager
    @StateObject private var relayCollection: NDKRelayCollection
    init(ndk: NDK, nostrManager: NostrManager) {
        self.ndk = ndk
        self.nostrManager = nostrManager
        self._relayCollection = StateObject(wrappedValue: ndk.createRelayCollection())
    }
    var body: some View {
        Group {
            if relayCollection.relays.isEmpty {
                VStack(spacing: 16) {
                    Image(systemName: "network.slash")
                        .font(.system(size: 60))
                        .foregroundStyle(Color.white.opacity(0.3))
                    Text("No relays configured")
                        .font(.headline)
                        .foregroundStyle(Color.white.opacity(0.6))
                    Text("Add relays to connect to the Nostr network")
                        .font(.subheadline)
                        .foregroundStyle(Color.white.opacity(0.4))
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 40)
                .listRowBackground(Color.clear)
            } else {
                Section {
                    ForEach(relayCollection.relays) { relayInfo in
                        RelayRowView(relayInfo: relayInfo, ndk: ndk, nostrManager: nostrManager)
                    }
                } header: {
                    HStack {
                        Text("Connected Relays")
                            .foregroundColor(Color.white.opacity(0.8))
                        Spacer()
                        Text("\(relayCollection.connectedCount)/\(relayCollection.totalCount)")
                            .font(.caption)
                            .foregroundStyle(Color.white.opacity(0.6))
                    }
                }
            }
        }
    }
}
// Individual relay row using relay info from collection
struct RelayRowView: View {
    let relayInfo: NDKRelayCollection.RelayInfo
    let ndk: NDK
    let nostrManager: NostrManager
    @State private var showDetails = false
    @State private var relay: NDKRelay?
    @State private var relayState: NDKRelay.State?
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                // Connection status indicator
                Circle()
                    .fill(connectionColor)
                    .frame(width: 8, height: 8)
                VStack(alignment: .leading, spacing: 4) {
                    Text(relayInfo.url)
                        .font(.headline)
                        .foregroundColor(.white)
                        .lineLimit(1)
                    HStack(spacing: 12) {
                        ConnectionStatusBadge(state: relayInfo.state, style: .compact)
                        if let state = relayState,
                           let name = state.info?.name {
                            Text(name)
                                .font(.caption)
                                .foregroundStyle(Color.white.opacity(0.6))
                        }
                    }
                }
                Spacer()
                Image(systemName: "chevron.right")
                    .foregroundStyle(Color.white.opacity(0.3))
            }
            // Stats row
            if let state = relayState {
                RelayStatsRow(stats: state.stats)
            }
        }
        .padding(.vertical, 4)
        .listRowBackground(Color.white.opacity(0.05))
        .contentShape(Rectangle())
        .onTapGesture {
            showDetails = true
        }
        .sheet(isPresented: $showDetails) {
            if let relay = relay, let state = relayState {
                RelayDetailView(relay: relay, initialState: state, nostrManager: nostrManager)
            }
        }
        .task {
            await loadRelay()
        }
    }
    private var connectionColor: Color {
        switch relayInfo.state {
        case .connected:
            return .green
        case .connecting:
            return .orange
        case .disconnected:
            return .gray
        case .disconnecting:
            return .orange
        case .failed:
            return .red
        }
    }
    private func loadRelay() async {
        let allRelays = await ndk.relays
        if let foundRelay = allRelays.first(where: { $0.url == relayInfo.url }) {
            self.relay = foundRelay
            // Get initial state
            for await state in foundRelay.stateStream {
                await MainActor.run {
                    self.relayState = state
                }
                // Only need the first state for display
                break
            }
        }
    }
}
// Simple connection status badge
struct ConnectionStatusBadge: View {
    let state: NDKRelayConnectionState
    let style: BadgeStyle
    enum BadgeStyle {
        case full
        case compact
    }
    var body: some View {
        if style == .compact {
            Text(statusText)
                .font(.caption)
                .fontWeight(.medium)
                .foregroundColor(statusColor)
        } else {
            HStack(spacing: 4) {
                Circle()
                    .fill(statusColor)
                    .frame(width: 8, height: 8)
                Text(statusText)
                    .font(.caption)
                    .fontWeight(.medium)
            }
            .padding(.horizontal, 8)
            .padding(.vertical, 2)
            .background(statusColor.opacity(0.2))
            .cornerRadius(12)
        }
    }
    private var statusColor: Color {
        switch state {
        case .connected:
            return .green
        case .connecting:
            return .orange
        case .disconnected:
            return .gray
        case .disconnecting:
            return .orange
        case .failed:
            return .red
        }
    }
    private var statusText: String {
        switch state {
        case .connected:
            return "Connected"
        case .connecting:
            return "Connecting"
        case .disconnected:
            return "Disconnected"
        case .disconnecting:
            return "Disconnecting"
        case .failed:
            return "Failed"
        }
    }
}
// Simple relay stats row
struct RelayStatsRow: View {
    let stats: NDKRelayStats
    var body: some View {
        HStack(spacing: 16) {
            StatItem(
                icon: "arrow.up",
                value: "\(stats.messagesSent)",
                label: "sent"
            )
            StatItem(
                icon: "arrow.down",
                value: "\(stats.messagesReceived)",
                label: "received"
            )
            if let latency = stats.latency {
                StatItem(
                    icon: "timer",
                    value: String(format: "%.0fms", latency * 1000),
                    label: "latency"
                )
            }
        }
        .font(.caption)
        .foregroundStyle(Color.white.opacity(0.6))
    }
}
struct StatItem: View {
    let icon: String
    let value: String
    let label: String
    var body: some View {
        VStack(spacing: 2) {
            HStack(spacing: 2) {
                Image(systemName: icon)
                    .font(.system(size: 10))
                Text(value)
                    .fontWeight(.medium)
            }
            Text(label)
                .font(.system(size: 9))
        }
    }
}
// MARK: - Relay Detail View
struct RelayDetailView: View {
    let relay: NDKRelay
    let initialState: NDKRelay.State
    let nostrManager: NostrManager
    @Environment(\.dismiss) private var dismiss
    @State private var currentState: NDKRelay.State
    @State private var showDisconnectAlert = false
    @State private var observationTask: Task<Void, Never>?
    init(relay: NDKRelay, initialState: NDKRelay.State, nostrManager: NostrManager) {
        self.relay = relay
        self.initialState = initialState
        self.nostrManager = nostrManager
        self._currentState = State(initialValue: initialState)
    }
    var body: some View {
        NavigationView {
            List {
                // Connection Status
                Section("Connection") {
                    LabeledContent("Status", value: statusText)
                        .foregroundColor(.white)
                    if let connectedAt = currentState.stats.connectedAt {
                        LabeledContent("Connected Since") {
                            Text(connectedAt, style: .relative)
                                .foregroundColor(Color.white.opacity(0.6))
                        }
                        .foregroundColor(.white)
                    }
                    if let lastMessage = currentState.stats.lastMessageAt {
                        LabeledContent("Last Message") {
                            Text(lastMessage, style: .relative)
                                .foregroundColor(Color.white.opacity(0.6))
                        }
                        .foregroundColor(.white)
                    }
                }
                .listRowBackground(Color.white.opacity(0.05))
                // Traffic Statistics
                Section("Traffic") {
                    LabeledContent("Messages Sent", value: "\(currentState.stats.messagesSent)")
                        .foregroundColor(.white)
                    LabeledContent("Messages Received", value: "\(currentState.stats.messagesReceived)")
                        .foregroundColor(.white)
                    LabeledContent("Bytes Sent", value: formatBytes(currentState.stats.bytesSent))
                        .foregroundColor(.white)
                    LabeledContent("Bytes Received", value: formatBytes(currentState.stats.bytesReceived))
                        .foregroundColor(.white)
                    if let latency = currentState.stats.latency {
                        LabeledContent("Latency", value: String(format: "%.0f ms", latency * 1000))
                            .foregroundColor(.white)
                    }
                }
                .listRowBackground(Color.white.opacity(0.05))
                // Actions
                Section {
                    if case .connected = currentState.connectionState {
                        Button(role: .destructive, action: { showDisconnectAlert = true }) {
                            Label("Disconnect", systemImage: "xmark.circle")
                                .foregroundColor(.red)
                        }
                    } else {
                        Button(action: reconnect) {
                            Label("Connect", systemImage: "arrow.clockwise")
                                .foregroundColor(.purple)
                        }
                    }
                    // Allow removing user-added relays
                    if nostrManager.userAddedRelays.contains(relay.url) {
                        Button(role: .destructive, action: removeRelay) {
                            Label("Remove from App", systemImage: "trash")
                                .foregroundColor(.red)
                        }
                    }
                }
                .listRowBackground(Color.white.opacity(0.05))
            }
            .navigationTitle(relay.url)
            .navigationBarTitleDisplayMode(.inline)
            .scrollContentBackground(.hidden)
            .background(
                LinearGradient(
                    gradient: Gradient(colors: [
                        Color(red: 0.05, green: 0.02, blue: 0.08),
                        Color(red: 0.02, green: 0.01, blue: 0.03),
                        Color.black
                    ]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
            )
            .toolbar {
                ToolbarItem(placement: .confirmationAction) {
                    Button("Done") { dismiss() }
                        .foregroundColor(.purple)
                }
            }
            .alert("Disconnect Relay?", isPresented: $showDisconnectAlert) {
                Button("Cancel", role: .cancel) { }
                Button("Disconnect", role: .destructive) {
                    Task {
                        await relay.disconnect()
                        dismiss()
                    }
                }
            } message: {
                Text("Are you sure you want to disconnect from this relay?")
            }
            .onAppear {
                startObserving()
            }
            .onDisappear {
                stopObserving()
            }
        }
        .preferredColorScheme(.dark)
    }
    private var statusText: String {
        switch currentState.connectionState {
        case .connected:
            return "Connected"
        case .connecting:
            return "Connecting..."
        case .disconnected:
            return "Disconnected"
        case .disconnecting:
            return "Disconnecting..."
        case .failed(let error):
            return "Failed: \(error)"
        }
    }
    private func reconnect() {
        Task {
            do {
                try await relay.connect()
                dismiss()
            } catch {
                print("Failed to reconnect: \(error)")
            }
        }
    }
    private func removeRelay() {
        Task {
            // Remove relay from NDK
            await relay.disconnect()
            // Remove from persistent storage
            nostrManager.removeUserRelay(relay.url)
            await MainActor.run {
                dismiss()
            }
        }
    }
    private func formatBytes(_ bytes: Int) -> String {
        let formatter = ByteCountFormatter()
        formatter.countStyle = .binary
        return formatter.string(fromByteCount: Int64(bytes))
    }
    private func startObserving() {
        observationTask = Task {
            for await state in relay.stateStream {
                await MainActor.run {
                    self.currentState = state
                }
            }
        }
    }
    private func stopObserving() {
        observationTask?.cancel()
        observationTask = nil
    }
}
// MARK: - Add Relay View
struct AddRelayView: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject var nostrManager: NostrManager
    @State private var relayURL = ""
    @State private var isAdding = false
    @State private var showError = false
    @State private var errorMessage = ""
    // Common relays
    let suggestedRelays = [
        RelayConstants.damus,
        RelayConstants.nostrBand,
        "wss://relayable.org",
        RelayConstants.primal,
        RelayConstants.nostrWine
    ]
    var body: some View {
        NavigationStack {
            Form {
                Section {
                    TextField("wss://relay.example.com", text: $relayURL)
                        .textContentType(.URL)
                        #if os(iOS)
                        .autocapitalization(.none)
                        #endif
                        .autocorrectionDisabled()
                        .foregroundColor(.white)
                } header: {
                    Text("Relay URL")
                        .foregroundColor(Color.white.opacity(0.8))
                } footer: {
                    Text("Enter a WebSocket URL for a Nostr relay")
                        .foregroundColor(Color.white.opacity(0.6))
                }
                Section("Suggested Relays") {
                    ForEach(suggestedRelays, id: \.self) { relay in
                        Button(action: { relayURL = relay }) {
                            HStack {
                                Text(relay)
                                    .foregroundColor(.white)
                                Spacer()
                                if relayURL == relay {
                                    Image(systemName: "checkmark")
                                        .foregroundColor(.purple)
                                }
                            }
                        }
                    }
                }
                Section {
                    Button(action: addRelay) {
                        if isAdding {
                            ProgressView()
                                .frame(maxWidth: .infinity)
                        } else {
                            Text("Add Relay")
                                .frame(maxWidth: .infinity)
                                .foregroundColor(.purple)
                        }
                    }
                    .disabled(relayURL.isEmpty || isAdding)
                }
            }
            .navigationTitle("Add Relay")
            .navigationBarTitleDisplayMode(.inline)
            .scrollContentBackground(.hidden)
            .background(
                LinearGradient(
                    gradient: Gradient(colors: [
                        Color(red: 0.05, green: 0.02, blue: 0.08),
                        Color(red: 0.02, green: 0.01, blue: 0.03),
                        Color.black
                    ]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
            )
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { dismiss() }
                        .foregroundColor(.purple)
                }
            }
            .alert("Error", isPresented: $showError) {
                Button("OK") { }
            } message: {
                Text(errorMessage)
            }
        }
        .preferredColorScheme(.dark)
    }
    private func addRelay() {
        guard !relayURL.isEmpty else { return }
        isAdding = true
        Task {
            do {
                // Add relay to NDK and connect to it
                guard let ndk = nostrManager.ndk else {
                    throw NostrError.signerRequired
                }
                guard let _ = await ndk.addRelayAndConnect(relayURL) else {
                    throw NostrError.networkError
                }
                // Persist the relay for future app launches
                nostrManager.addUserRelay(relayURL)
                await MainActor.run {
                    dismiss()
                }
            } catch {
                await MainActor.run {
                    errorMessage = error.localizedDescription
                    showError = true
                    isAdding = false
                }
            }
        }
    }
}
</file>

<file path="Sources/Ambulando/Views/RelaySelectorView.swift">
import SwiftUI
import NDKSwift
struct RelaySelectorView: View {
    @EnvironmentObject var nostrManager: NostrManager
    @EnvironmentObject var appState: AppState
    @Binding var selectedRelay: String?
    @Binding var isPresented: Bool
    @State private var relayStates: [RelayInfo] = []
    @State private var observerTask: Task<Void, Never>?
    struct RelayInfo: Identifiable {
        let id = UUID()
        let url: String
        let isConnected: Bool
        let info: NDKRelayInformation?
    }
    var body: some View {
        VStack(spacing: 0) {
            // Header
            HStack {
                Text("SELECT RELAY")
                    .font(.system(size: 16, weight: .bold))
                    .foregroundColor(.white)
                Spacer()
                Button(action: {
                    isPresented = false
                }) {
                    Image(systemName: "xmark.circle.fill")
                        .font(.system(size: 24))
                        .foregroundColor(.white.opacity(0.6))
                }
            }
            .padding(.horizontal, 20)
            .padding(.vertical, 16)
            .background(Color.black.opacity(0.3))
            // All relays option
            RelaySelectorRowView(
                title: "All Relays",
                subtitle: "\(relayStates.filter { $0.isConnected }.count) connected",
                isSelected: selectedRelay == nil,
                isConnected: true,
                iconURL: nil
            ) {
                selectedRelay = nil
                isPresented = false
            }
            Divider()
                .background(Color.white.opacity(0.1))
            // Individual relays
            ScrollView {
                VStack(spacing: 0) {
                    ForEach(relayStates) { relay in
                        RelaySelectorRowView(
                            title: relay.info?.name ?? formatRelayUrl(relay.url),
                            subtitle: relay.isConnected ? "Connected" : "Disconnected",
                            isSelected: selectedRelay == relay.url,
                            isConnected: relay.isConnected,
                            iconURL: relay.info?.icon
                        ) {
                            selectedRelay = relay.url
                            isPresented = false
                        }
                        if relay.id != relayStates.last?.id {
                            Divider()
                                .background(Color.white.opacity(0.1))
                        }
                    }
                }
            }
        }
        .background(Color.black.opacity(0.95))
        .cornerRadius(16)
        .overlay(
            RoundedRectangle(cornerRadius: 16)
                .stroke(Color.white.opacity(0.1), lineWidth: 1)
        )
        .padding(20)
        .onAppear {
            startObservingRelays()
        }
        .onDisappear {
            observerTask?.cancel()
        }
    }
    private func formatRelayUrl(_ url: String) -> String {
        // Remove wss:// prefix and trailing slash for cleaner display
        var formatted = url
        if formatted.hasPrefix("wss://") {
            formatted = String(formatted.dropFirst(6))
        } else if formatted.hasPrefix("ws://") {
            formatted = String(formatted.dropFirst(5))
        }
        if formatted.hasSuffix("/") {
            formatted = String(formatted.dropLast())
        }
        return formatted
    }
    private func startObservingRelays() {
        guard let ndk = nostrManager.ndk else { return }
        observerTask = Task {
            // Get initial relay states
            let relays = await ndk.relays
            var states: [RelayInfo] = []
            for relay in relays {
                let connectionState = await relay.connectionState
                let isConnected = connectionState == .connected
                let info = await relay.info
                states.append(RelayInfo(url: relay.url, isConnected: isConnected, info: info))
            }
            await MainActor.run {
                self.relayStates = states.sorted { $0.url < $1.url }
            }
            // Listen for relay changes
            let changes = await ndk.relayChanges
            for await change in changes {
                switch change {
                case .relayAdded(let relay):
                    let isConnected = await relay.connectionState == .connected
                    let info = await relay.info
                    await MainActor.run {
                        if !self.relayStates.contains(where: { $0.url == relay.url }) {
                            self.relayStates.append(RelayInfo(url: relay.url, isConnected: isConnected, info: info))
                            self.relayStates.sort { $0.url < $1.url }
                        }
                    }
                case .relayRemoved(let url):
                    await MainActor.run {
                        self.relayStates.removeAll { $0.url == url }
                    }
                case .relayConnected(let relay):
                    let info = await relay.info
                    await MainActor.run {
                        if let index = self.relayStates.firstIndex(where: { $0.url == relay.url }) {
                            self.relayStates[index] = RelayInfo(url: relay.url, isConnected: true, info: info)
                        }
                    }
                case .relayDisconnected(let relay):
                    let info = await relay.info
                    await MainActor.run {
                        if let index = self.relayStates.firstIndex(where: { $0.url == relay.url }) {
                            self.relayStates[index] = RelayInfo(url: relay.url, isConnected: false, info: info)
                        }
                    }
                }
            }
        }
    }
}
struct RelaySelectorRowView: View {
    let title: String
    let subtitle: String
    let isSelected: Bool
    let isConnected: Bool
    let iconURL: String?
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            HStack(spacing: 12) {
                // Relay icon if available
                if let iconURL = iconURL, let url = URL(string: iconURL) {
                    AsyncImage(url: url) { image in
                        image
                            .resizable()
                            .scaledToFill()
                    } placeholder: {
                        Circle()
                            .fill(Color.white.opacity(0.1))
                            .overlay(
                                ProgressView()
                                    .scaleEffect(0.5)
                            )
                    }
                    .frame(width: 32, height: 32)
                    .clipShape(Circle())
                } else {
                    // Default icon for relays without custom icon
                    Circle()
                        .fill(Color.white.opacity(0.1))
                        .frame(width: 32, height: 32)
                        .overlay(
                            Image(systemName: "network")
                                .font(.system(size: 16))
                                .foregroundColor(Color.white.opacity(0.5))
                        )
                }
                VStack(alignment: .leading, spacing: 2) {
                    Text(title)
                        .font(.system(size: 15, weight: .medium))
                        .foregroundColor(.white)
                        .lineLimit(1)
                    HStack(spacing: 4) {
                        Circle()
                            .fill(isConnected ? Color.green : Color.red.opacity(0.6))
                            .frame(width: 6, height: 6)
                        Text(subtitle)
                            .font(.system(size: 12))
                            .foregroundColor(Color.white.opacity(0.6))
                    }
                }
                Spacer()
                if isSelected {
                    Image(systemName: "checkmark.circle.fill")
                        .font(.system(size: 20))
                        .foregroundColor(.purple)
                }
            }
            .padding(.horizontal, 20)
            .padding(.vertical, 12)
            .background(isSelected ? Color.purple.opacity(0.1) : Color.clear)
        }
        .buttonStyle(PlainButtonStyle())
    }
}
</file>

<file path="Sources/Ambulando/Views/SettingsView.swift">
import SwiftUI
import NDKSwift
struct SettingsView: View {
    @EnvironmentObject var nostrManager: NostrManager
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) private var dismiss
    @State private var currentUser: NDKUser?
    @State private var userProfile: NDKUserProfile?
    @State private var copiedNpub = false
    var body: some View {
        List {
            // Account section
            AccountSectionView(
                currentUser: currentUser,
                userProfile: userProfile,
                copiedNpub: copiedNpub,
                onCopyNpub: copyNpub
            )
            // Preferences
            Section(header: Text("Preferences").foregroundColor(Color.white.opacity(0.8))) {
                NavigationLink(destination: RelayManagementView()) {
                    Label("Relays", systemImage: "network")
                }
                .foregroundColor(.white)
                NavigationLink(destination: BlossomSettingsView(ndk: nostrManager.ndk)) {
                    Label("Blossom Servers", systemImage: "icloud.and.arrow.up")
                        .foregroundColor(.white)
                }
                .foregroundColor(.white)
                NavigationLink(destination: MuteListView()) {
                    Label("Muted Users", systemImage: "speaker.slash")
                }
                .foregroundColor(.white)
            }
            .listRowBackground(Color.white.opacity(0.05))
            // App Info
            Section(header: Text("App").foregroundColor(Color.white.opacity(0.8))) {
                LabeledContent("Version", value: "1.0.0")
                    .foregroundColor(.white)
                Link(destination: URL(string: "https://github.com/nostr-dev-kit/ndk-swift")!) {
                    Label("Source Code", systemImage: "chevron.left.forwardslash.chevron.right")
                }
                .foregroundColor(.white)
            }
            .listRowBackground(Color.white.opacity(0.05))
            // Debug section (only in debug builds)
            #if DEBUG
            Section(header: Text("Debug").foregroundColor(Color.white.opacity(0.8))) {
                NavigationLink(destination: DebugMenuView()) {
                    Label("Debug Tools", systemImage: "hammer.fill")
                }
                .foregroundColor(.white)
            }
            .listRowBackground(Color.white.opacity(0.05))
            #endif
            // Danger zone
            Section {
                Button(role: .destructive, action: logout) {
                    Label("Sign Out", systemImage: "rectangle.portrait.and.arrow.right")
                        .foregroundColor(.red)
                }
            }
            .listRowBackground(Color.white.opacity(0.05))
        }
        .navigationTitle("Settings")
        .navigationBarTitleDisplayMode(.inline)
        .scrollContentBackground(.hidden)
        .background(
                LinearGradient(
                    gradient: Gradient(colors: [
                        Color(red: 0.05, green: 0.02, blue: 0.08),
                        Color(red: 0.02, green: 0.01, blue: 0.03),
                        Color.black
                    ]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
            )
            .ignoresSafeArea()
        )
        .toolbar {
            ToolbarItem(placement: .confirmationAction) {
                Button("Done") {
                    dismiss()
                }
                .foregroundColor(.purple)
            }
        }
        .task {
            await loadUserData()
        }
        .preferredColorScheme(.dark)
    }
    private func loadUserData() async {
        guard let ndk = nostrManager.ndk else { return }
        // Get the current user from the active session
        if let activeSession = nostrManager.authManager.activeSession {
            let pubkey = activeSession.pubkey
            currentUser = NDKUser(pubkey: pubkey)
            appState.currentUser = currentUser
            // Fetch profile using NDKProfileManager
            for await profile in await ndk.profileManager.observe(for: pubkey, maxAge: TimeConstants.hour) {
                userProfile = profile
                break // Take first profile
            }
        }
    }
    private func copyNpub(_ npub: String) {
        #if os(iOS)
        UIPasteboard.general.string = npub
        #else
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(npub, forType: .string)
        #endif
        withAnimation {
            copiedNpub = true
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            withAnimation {
                copiedNpub = false
            }
        }
    }
    private func logout() {
        nostrManager.logout()
        appState.reset()
        dismiss()
    }
}
// MARK: - Mute List View (Placeholder)
struct MuteListView: View {
    @EnvironmentObject var nostrManager: NostrManager
    @State private var mutedUsers: Set<String> = []
    var body: some View {
        List {
            if mutedUsers.isEmpty {
                Text("No muted users")
                    .foregroundStyle(Color.white.opacity(0.6))
                    .frame(maxWidth: .infinity, alignment: .center)
                    .listRowBackground(Color.clear)
            } else {
                ForEach(Array(mutedUsers), id: \.self) { pubkey in
                    HStack {
                        Text(String(pubkey.prefix(16)) + "...")
                            .font(.system(.body, design: .monospaced))
                            .foregroundColor(.white)
                        Spacer()
                    }
                    .listRowBackground(Color.white.opacity(0.05))
                }
            }
        }
        .navigationTitle("Muted Users")
        .navigationBarTitleDisplayMode(.inline)
        .scrollContentBackground(.hidden)
        .background(
            LinearGradient(
                gradient: Gradient(colors: [
                    Color(red: 0.05, green: 0.02, blue: 0.08),
                    Color(red: 0.02, green: 0.01, blue: 0.03),
                    Color.black
                ]),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .ignoresSafeArea()
        )
        .task {
            await loadMutedUsers()
        }
    }
    private func loadMutedUsers() async {
        guard let ndk = nostrManager.ndk,
              let sessionData = ndk.sessionData else { return }
        mutedUsers = sessionData.muteList
    }
}
</file>

<file path="Sources/Ambulando/Views/UserProfileView.swift">
import SwiftUI
import NDKSwift
import NDKSwiftUI
struct UserProfileView: View {
    let pubkey: String
    @EnvironmentObject var nostrManager: NostrManager
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) private var dismiss
    @State private var profile: NDKUserProfile?
    @State private var isFollowing = false
    @State private var followersCount = 0
    @State private var followingCount = 0
    @State private var audioEvents: [AudioEvent] = []
    @State private var audioEventsTask: Task<Void, Never>?
    var body: some View {
        ScrollView {
            VStack(spacing: 24) {
                // Header with profile picture and stats
                VStack(spacing: 16) {
                    NDKProfilePicture(pubkey: pubkey, size: 120)
                    VStack(spacing: 8) {
                        Text(profile?.displayName ?? profile?.name ?? String(pubkey.prefix(16)))
                            .font(.system(size: 24, weight: .bold))
                            .foregroundColor(.white)
                        if let nip05 = profile?.nip05 {
                            HStack(spacing: 4) {
                                Image(systemName: "checkmark.seal.fill")
                                    .font(.system(size: 14))
                                    .foregroundColor(.purple)
                                Text(nip05)
                                    .font(.system(size: 14))
                                    .foregroundColor(Color.white.opacity(0.7))
                            }
                        }
                    }
                    // Stats
                    HStack(spacing: 40) {
                        VStack {
                            Text("\(followersCount)")
                                .font(.system(size: 20, weight: .semibold))
                                .foregroundColor(.white)
                            Text("Followers")
                                .font(.system(size: 12))
                                .foregroundColor(Color.white.opacity(0.6))
                        }
                        VStack {
                            Text("\(followingCount)")
                                .font(.system(size: 20, weight: .semibold))
                                .foregroundColor(.white)
                            Text("Following")
                                .font(.system(size: 12))
                                .foregroundColor(Color.white.opacity(0.6))
                        }
                    }
                    .padding(.top, 8)
                    // Follow button
                    if pubkey != appState.currentUser?.pubkey {
                        Button(action: toggleFollow) {
                            Text(isFollowing ? "Following" : "Follow")
                                .font(.system(size: 16, weight: .semibold))
                                .foregroundColor(isFollowing ? .white : .black)
                                .frame(maxWidth: 200)
                                .padding(.vertical, 12)
                                .background(
                                    RoundedRectangle(cornerRadius: 20)
                                        .fill(isFollowing ? Color.white.opacity(0.2) : Color.white)
                                )
                                .overlay(
                                    RoundedRectangle(cornerRadius: 20)
                                        .stroke(Color.white, lineWidth: isFollowing ? 1 : 0)
                                )
                        }
                    }
                }
                .padding(.top, 20)
                // About section
                if let about = profile?.about, !about.isEmpty {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("About")
                            .font(.system(size: 18, weight: .semibold))
                            .foregroundColor(.white)
                        Text(about)
                            .font(.system(size: 14))
                            .foregroundColor(Color.white.opacity(0.8))
                            .multilineTextAlignment(.leading)
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .padding(.horizontal)
                }
                // Audio events section
                VStack(alignment: .leading, spacing: 12) {
                    Text("Audio Posts")
                        .font(.system(size: 18, weight: .semibold))
                        .foregroundColor(.white)
                        .padding(.horizontal)
                    if audioEvents.isEmpty {
                        VStack(spacing: 12) {
                            Image(systemName: "waveform.circle")
                                .font(.system(size: 40))
                                .foregroundColor(Color.white.opacity(0.3))
                            Text("No audio posts yet")
                                .font(.system(size: 14))
                                .foregroundColor(Color.white.opacity(0.5))
                        }
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 40)
                    } else {
                        // Display audio events
                        LazyVStack(spacing: 0) {
                            ForEach(audioEvents.sorted { $0.createdAt > $1.createdAt }) { audioEvent in
                                AudioEventCard(audioEvent: audioEvent)
                                Divider()
                                    .background(Color.white.opacity(0.1))
                            }
                        }
                    }
                }
                .padding(.top, 16)
                Spacer(minLength: 40)
            }
        }
        .background(Color.black)
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button("Done") {
                    dismiss()
                }
                .foregroundColor(.white)
            }
        }
        .onAppear {
            loadProfile()
            checkFollowStatus()
            loadAudioEvents()
        }
        .onDisappear {
            audioEventsTask?.cancel()
        }
    }
    private func loadProfile() {
        Task {
            guard let ndk = nostrManager.ndk else { return }
            for await profile in ndk.profileManager.observe(for: pubkey, maxAge: TimeConstants.hour) {
                await MainActor.run {
                    self.profile = profile
                }
                break // Just get the first result for now
            }
        }
    }
    private func checkFollowStatus() {
        guard let ndk = nostrManager.ndk,
              let sessionData = ndk.sessionData else { return }
        isFollowing = sessionData.followList.contains(pubkey)
    }
    private func toggleFollow() {
        // TODO: Implement follow/unfollow functionality
        isFollowing.toggle()
    }
    private func loadAudioEvents() {
        guard let ndk = nostrManager.ndk else { return }
        // Cancel any existing task
        audioEventsTask?.cancel()
        // Clear existing events
        audioEvents.removeAll()
        // Create filter for audio events by this user
        let filter = NDKFilter(
            authors: [pubkey],
            kinds: [1222, 1244]
        )
        // Stream audio events
        let dataSource = ndk.observe(filter: filter, maxAge: 0, cachePolicy: .cacheWithNetwork)
        audioEventsTask = Task {
            for await event in dataSource.events {
                // Check if task was cancelled
                if Task.isCancelled { break }
                // Get WOT score from session data
                let wotScore: Double
                if let sessionData = ndk.sessionData {
                    let score = sessionData.webOfTrust[event.pubkey] ?? 0
                    // Normalize score (direct follows have Int.max)
                    wotScore = score == Int.max ? 1.0 : min(Double(score) / 10.0, 1.0)
                } else {
                    wotScore = 0.1
                }
                if let audioEvent = AudioEvent.from(event: event, webOfTrustScore: wotScore) {
                    await MainActor.run {
                        // Add new event if it doesn't already exist
                        if !self.audioEvents.contains(where: { $0.id == audioEvent.id }) {
                            self.audioEvents.append(audioEvent)
                        }
                    }
                }
            }
        }
    }
}
</file>

<file path="Sources/Ambulando/AmbulandoApp.swift">
import SwiftUI
import NDKSwift
@main
struct AmbulandoApp: App {
    @StateObject private var nostrManager = NostrManager()
    @StateObject private var appState = AppState()
    @StateObject private var blossomServerManager: BlossomServerManager
    init() {
        let manager = NostrManager()
        self._nostrManager = StateObject(wrappedValue: manager)
        self._blossomServerManager = StateObject(wrappedValue: BlossomServerManager(ndk: manager.ndk))
    }
    var body: some Scene {
        WindowGroup {
            ContentView()
            .environment(\.colorScheme, .dark)
            .preferredColorScheme(.dark)
            .environmentObject(nostrManager)
            .environmentObject(appState)
            .environmentObject(blossomServerManager)
        }
    }
}
// MARK: - App State
@MainActor
class AppState: ObservableObject {
    @Published var isAuthenticated = false
    @Published var currentUser: NDKUser?
    // Audio state
    @Published var isRecording = false
    @Published var currentlyPlayingId: String?
    @Published var recordingStartTime: Date?
    // Reply context
    @Published var replyingTo: AudioEvent?
    // Signer reference for reactions
    var signer: NDKSigner? {
        nostrManager?.ndk?.signer
    }
    // Lazy reference to NostrManager
    private weak var nostrManager: NostrManager?
    func setNostrManager(_ manager: NostrManager) {
        self.nostrManager = manager
    }
    func reset() {
        isAuthenticated = false
        currentUser = nil
        isRecording = false
        currentlyPlayingId = nil
        replyingTo = nil
    }
}
// MARK: - Nostr Manager
@MainActor
class NostrManager: ObservableObject {
    @Published var ndk: NDK?
    @Published var authenticationState: NDKAuthManager.AuthenticationState = .unauthenticated
    private var ndkAuthManager: NDKAuthManager
    private var authStateObservation: Task<Void, Never>?
    // Recommended relays for Ambulando
    let defaultRelays = [
        RelayConstants.primal,
        RelayConstants.damus,
        RelayConstants.nosLol,
        RelayConstants.nostrBand,
        RelayConstants.nostrWine
    ]
    // Key for storing user-added relays
    private static let userRelaysKey = "AmbulandoUserAddedRelays"
    init() {
        self.ndkAuthManager = NDKAuthManager.shared
        setupNDK()
    }
    private func setupNDK() {
        let allRelays = getAllRelays()
        ndk = NDK(relayUrls: allRelays)
        if let ndk = ndk {
            // Configure client tag
            ndk.clientTagConfig = NDKClientTagConfig(
                name: "Ambulando",
                autoTag: true
            )
            ndkAuthManager.setNDK(ndk)
            // Setup session restoration
            Task {
                await ndk.connect()
                // Observe authentication state changes
                _ = withObservationTracking {
                    ndkAuthManager.authenticationState
                } onChange: { [weak self] in
                    Task { @MainActor in
                        await self?.handleAuthStateChange()
                    }
                }
                await handleAuthStateChange()
            }
        }
    }
    private func handleAuthStateChange() async {
        switch ndkAuthManager.authenticationState {
        case .authenticated:
            // If authenticated, ensure signer is set on NDK
            if let activeSigner = ndkAuthManager.activeSigner {
                ndk?.signer = activeSigner
                // Start session if not already started
                if ndk?.sessionData == nil {
                    do {
                        _ = try await ndk?.startSession(
                            signer: activeSigner,
                            config: NDKSessionConfiguration(
                                dataRequirements: [.followList, .muteList, .webOfTrust(depth: 2)],
                                preloadStrategy: .progressive
                            )
                        )
                    } catch {
                        // Session start failed
                    }
                }
            }
        case .unauthenticated:
            // Clear signer if unauthenticated
            ndk?.signer = nil
        default:
            break
        }
        // Trigger UI update
        objectWillChange.send()
    }
    func login(with signer: NDKSigner) async throws -> NDKSessionData {
        guard let ndk = ndk else { throw NostrError.signerRequired }
        // For bunker signers, the signer should already be set on NDK
        // and connected before calling this method
        if signer is NDKBunkerSigner {
            // Start session with the bunker signer
            let sessionData = try await ndk.startSession(
                signer: signer,
                config: NDKSessionConfiguration(
                    dataRequirements: [.followList, .muteList, .webOfTrust(depth: 2)],
                    preloadStrategy: .progressive
                )
            )
            // Note: We don't persist bunker signers to keychain
            // The connection token should be saved separately if needed
            return sessionData
        } else {
            // For private key signers, start session normally
            let sessionData = try await ndk.startSession(
                signer: signer,
                config: NDKSessionConfiguration(
                    dataRequirements: [.followList, .muteList, .webOfTrust(depth: 2)],
                    preloadStrategy: .progressive
                )
            )
            // Create or update session with auth manager for persistence
            if let privateSigner = signer as? NDKPrivateKeySigner {
                _ = try await ndkAuthManager.createSession(
                    with: privateSigner,
                    requiresBiometric: false,
                    isHardwareBacked: false
                )
            }
            return sessionData
        }
    }
    func logout() {
        Task {
            // Clear all sessions from keychain
            for session in ndkAuthManager.availableSessions {
                try? await ndkAuthManager.deleteSession(session)
            }
        }
        // Clear active authentication state
        ndkAuthManager.logout()
        // Clear NDK signer
        ndk?.signer = nil
    }
    // Check if user is authenticated via NDKAuth
    var isAuthenticated: Bool {
        // Must have both auth manager authenticated AND signer loaded
        ndkAuthManager.isAuthenticated && ndk?.signer != nil
    }
    // Get auth manager for use in UI
    var authManager: NDKAuthManager {
        return ndkAuthManager
    }
    // MARK: - Relay Management
    /// Get all relays (default + user-added)
    private func getAllRelays() -> [String] {
        let userRelays = getUserAddedRelays()
        let allRelays = defaultRelays + userRelays
        return Array(Set(allRelays)) // Remove duplicates
    }
    /// Get user-added relays from UserDefaults
    private func getUserAddedRelays() -> [String] {
        return UserDefaults.standard.stringArray(forKey: Self.userRelaysKey) ?? []
    }
    /// Add a user relay and persist it
    func addUserRelay(_ relayURL: String) {
        var userRelays = getUserAddedRelays()
        guard !userRelays.contains(relayURL) && !defaultRelays.contains(relayURL) else {
            print("Relay \(relayURL) already exists")
            return
        }
        userRelays.append(relayURL)
        UserDefaults.standard.set(userRelays, forKey: Self.userRelaysKey)
    }
    /// Remove a user relay and persist the change
    func removeUserRelay(_ relayURL: String) {
        var userRelays = getUserAddedRelays()
        userRelays.removeAll(value: relayURL)
        UserDefaults.standard.set(userRelays, forKey: Self.userRelaysKey)
    }
    /// Get list of user-added relays (for UI display)
    var userAddedRelays: [String] {
        return getUserAddedRelays()
    }
}
// MARK: - Errors
enum NostrError: LocalizedError {
    case signerRequired
    case invalidKey
    case networkError
    var errorDescription: String? {
        switch self {
        case .signerRequired:
            return "No signer available"
        case .invalidKey:
            return "Invalid private key"
        case .networkError:
            return "Network connection failed"
        }
    }
}
</file>

<file path="Sources/Ambulando/AmbulandoIcon.swift">
import SwiftUI
struct AmbulandoIcon: View {
    let size: CGFloat
    var body: some View {
        ZStack {
            // Gradient background
            LinearGradient(
                gradient: Gradient(colors: [
                    Color(red: 0.6, green: 0.1, blue: 0.6),
                    Color(red: 0.5, green: 0.05, blue: 0.5),
                    Color(red: 0.7, green: 0.15, blue: 0.7)
                ]),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            // Main footprint
            FootprintShape()
                .fill(Color.white.opacity(0.85))
                .frame(width: size * 0.65, height: size * 0.75)
                .rotationEffect(.degrees(-15))
                .offset(x: -size * 0.05, y: -size * 0.05)
            // Shadow footprint for depth
            FootprintShape()
                .fill(Color(red: 0.4, green: 0.05, blue: 0.4).opacity(0.3))
                .frame(width: size * 0.65, height: size * 0.75)
                .rotationEffect(.degrees(-15))
                .offset(x: -size * 0.03, y: -size * 0.03)
                .blur(radius: size * 0.02)
        }
        .frame(width: size, height: size)
        .clipShape(RoundedRectangle(cornerRadius: size * 0.2237))
    }
}
// Preview for development
struct AmbulandoIcon_Previews: PreviewProvider {
    static var previews: some View {
        VStack(spacing: 20) {
            AmbulandoIcon(size: 180)
            AmbulandoIcon(size: 120)
            AmbulandoIcon(size: 60)
        }
        .padding()
        .background(Color.gray)
    }
}
</file>

<file path="Sources/Ambulando/ContentView.swift">
import SwiftUI
import NDKSwift
struct ContentView: View {
    @EnvironmentObject var nostrManager: NostrManager
    @EnvironmentObject var appState: AppState
    @EnvironmentObject var blossomServerManager: BlossomServerManager
    var body: some View {
        let authManager = NDKAuthManager.shared
        let isAuth = authManager.authenticationState == .authenticated && authManager.activeSession != nil && authManager.activeSigner != nil
        ZStack {
            Color.black.ignoresSafeArea()
            Group {
                if isAuth {
                    NavigationView {
                        HomeFeedView()
                    }
                    .environment(\.ndk, nostrManager.ndk)
                } else {
                    AuthenticationView()
                }
            }
        }
        .background(
            LinearGradient(
                gradient: Gradient(colors: [
                    Color(red: 0.05, green: 0.02, blue: 0.08),
                    Color(red: 0.02, green: 0.01, blue: 0.03),
                    Color.black
                ]),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .ignoresSafeArea()
        )
        .onAppear {
            appState.setNostrManager(nostrManager)
            checkAuthentication()
        }
        .environment(\.ndk, nostrManager.ndk)
        .onChange(of: authManager.isAuthenticated) { _, isAuthenticated in
            if isAuthenticated {
                blossomServerManager.loadServers()
                blossomServerManager.loadSuggestedServers()
            }
        }
    }
    private func checkAuthentication() {
        let authManager = NDKAuthManager.shared
        guard let session = authManager.activeSession else {
            appState.isAuthenticated = false
            appState.currentUser = nil
            return
        }
        appState.isAuthenticated = true
        appState.currentUser = nostrManager.ndk?.getUser(session.pubkey)
    }
}
</file>

<file path="Sources/Ambulando/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>Ambulando</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleVersion</key>
	<string>1</string>
	<key>ITSAppUsesNonExemptEncryption</key>
	<false/>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIRequiresFullScreen</key>
	<true/>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
	</array>
	<key>NSMicrophoneUsageDescription</key>
	<string>Ambulando uses the microphone to record audio for your walking sessions.</string>
</dict>
</plist>
</file>

<file path="build.sh">
#!/bin/bash
set -euo pipefail
# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color
# Get script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd "$SCRIPT_DIR"
# Get app name from directory
APP_NAME=$(basename "$SCRIPT_DIR")
echo -e "${YELLOW}🔄 Regenerating Xcode project...${NC}"
# Check if xcodegen is installed
if ! command -v xcodegen &> /dev/null; then
    echo -e "${RED}❌ xcodegen is not installed. Installing via Homebrew...${NC}"
    brew install xcodegen
fi
# Generate Xcode project
xcodegen generate
echo -e "${GREEN}✅ Xcode project regenerated${NC}"
# Build the project
echo -e "${YELLOW}🏗️  Building ${APP_NAME}...${NC}"
# Set default values
DESTINATION="${DESTINATION:-platform=iOS Simulator,name=iPhone 15 Pro}"
CONFIGURATION="${CONFIGURATION:-Debug}"
SCHEME="${SCHEME:-$APP_NAME}"
# Build with xcbeautify for cleaner output
set -o pipefail && xcodebuild \
    -project "${APP_NAME}.xcodeproj" \
    -scheme "$SCHEME" \
    -destination "$DESTINATION" \
    -configuration "$CONFIGURATION" \
    build \
    | xcbeautify
echo -e "${GREEN}✅ Build completed successfully${NC}"
</file>

<file path="deploy.sh">
#!/bin/bash
cd "$(dirname "$0")/.."
./deploy-testflight.sh Ambulando
</file>

<file path="project.yml">
name: Ambulando
options:
  bundleIdPrefix: com.ambulando
  deploymentTarget:
    iOS: 17.0
  developmentLanguage: en
  xcodeVersion: "15.0"
  createIntermediateGroups: true
packages:
  NDKSwift:
    path: ../../../
targets:
  Ambulando:
    type: application
    platform: iOS
    sources:
      - Sources
    dependencies:
      - package: NDKSwift
        product: NDKSwift
      - package: NDKSwift
        product: NDKSwiftUI
    settings:
      base:
        PRODUCT_NAME: Ambulando
        PRODUCT_BUNDLE_IDENTIFIER: com.ambulando.app
        INFOPLIST_FILE: Sources/Ambulando/Info.plist
        # Code Signing Settings - Update these with your values
        DEVELOPMENT_TEAM: "456SHKPP26"
        CODE_SIGN_STYLE: Automatic
        CODE_SIGN_IDENTITY: "Apple Development"
        PROVISIONING_PROFILE_SPECIFIER: ""
        ASSETCATALOG_COMPILER_APPICON_NAME: AppIcon
        ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME: AccentColor
        TARGETED_DEVICE_FAMILY: "1,2"
        ENABLE_PREVIEWS: YES
        SWIFT_VERSION: 5.9
      configs:
        Debug:
          SWIFT_OPTIMIZATION_LEVEL: "-Onone"
          SWIFT_ACTIVE_COMPILATION_CONDITIONS: DEBUG
          DEBUG_INFORMATION_FORMAT: dwarf
        Release:
          SWIFT_OPTIMIZATION_LEVEL: "-O"
          DEBUG_INFORMATION_FORMAT: dwarf-with-dsym
    info:
      path: Sources/Ambulando/Info.plist
      properties:
        CFBundleDisplayName: Ambulando
        UILaunchStoryboardName: LaunchScreen
        UISupportedInterfaceOrientations:
          - UIInterfaceOrientationPortrait
        UIRequiresFullScreen: true
        ITSAppUsesNonExemptEncryption: false
</file>

<file path="README.md">
# AMBULANDO

A beautiful iOS app for voice-based conversations on Nostr. Share wisdom through voice messages with a focus on meaningful interactions.

## Features

- 🎙️ **Voice Messages**: Record and share up to 60-second voice messages
- 🔊 **Audio Playback**: Smooth playback with waveform visualization
- 🌐 **Web of Trust**: Content sorted by your social graph proximity
- ⚡ **Negentropy Sync**: Efficient syncing of follow lists
- 🎨 **Beautiful Animations**: Carefully crafted UI with attention to detail
- 🔐 **Secure Login**: Support for nsec private key login (NIP-46 coming soon)

## Architecture

Built with:
- SwiftUI for modern, declarative UI
- NDKSwift for Nostr protocol implementation
- AVFoundation for audio recording and playback
- Swift Concurrency for efficient network operations

## Voice Event Types

- **Kind 1222**: Root voice messages
- **Kind 1244**: Voice message replies

## Building

1. Generate Xcode project:
```bash
cd Examples/Apps/Ambulando
xcodegen generate
```

2. Open in Xcode:
```bash
open Ambulando.xcodeproj
```

3. Build and run on simulator or device

## Requirements

- iOS 16.0+
- Xcode 15.0+
- Swift 5.9+

## Status

This is an example app demonstrating NDKSwift capabilities with a focus on audio content and beautiful UI/UX.
</file>

<file path="refresh-project.sh">
#!/bin/bash
set -euo pipefail
# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color
# Get script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd "$SCRIPT_DIR"
echo -e "${YELLOW}🔄 Refreshing Xcode project after file changes...${NC}"
# Clean derived data if requested
if [[ "${CLEAN:-false}" == "true" ]]; then
    echo -e "${YELLOW}🧹 Cleaning derived data...${NC}"
    rm -rf .build/DerivedData
fi
# Regenerate project
xcodegen generate --spec project.yml
echo -e "${GREEN}✅ Project refreshed! The .xcodeproj now includes all current files.${NC}"
echo -e "${GREEN}   Code signing is configured from project.yml${NC}"
</file>

</files>
